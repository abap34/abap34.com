<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
<meta charset="UTF-8">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-10Y7GMS7GV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-10Y7GMS7GV');
    </script>

    <script type="text/javascript" src="//code.typesquare.com/static/ZDbTe4IzCko%253D/ts106f.js"
        charset="utf-8"></script>

    <title> (WIP) 【週刊 PEGパーサジェネレータ を作ろう】 [創刊号] [最終号] </title>

    <meta property="og:title" content="(WIP) 【週刊 PEGパーサジェネレータ を作ろう】 [創刊号] [最終号]">
    <meta property="og:image" content="https://images.dog.ceo/breeds/bluetick/n02088632_419.jpg">
    <meta property="og:description" content="PEGパーサジェネレータを作ります。いろいろな構文解析アルゴリズムの計算量の話もします。">
    <meta property="og:url" content="https://abap34.com/posts/tinypeg.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="abap34's blog">
    <meta property="og:locale" content="ja_JP">

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="" />

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <link rel="stylesheet" href="https://latex.vercel.app/style.css">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.3.2/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ext-language_tools.js"></script>

    <link rel="stylesheet" href="https://latex.vercel.app/prism/prism.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>


    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        h2 {
            border-bottom: 1px solid #d3d3d3;
            padding-bottom: 0.25em;
        }

        table {
            margin-top: 1em;
            margin-bottom: 1em;
            margin-left: auto;
            margin-right: auto;
        }

        .definition {
            margin-left: 1em;
            margin-right: 1em;
            border: 1px solid #d3d3d3;
            padding: 1em;
        }

        .footnote {
            border-top: 1px solid #d3d3d3;
            margin-top: 2em;
        }
    </style>


    <!-- Runner is not required. Skip this. -->


</head>


<body class="latex-dark-auto">

    <header>
        <h1>(WIP) 【週刊 PEGパーサジェネレータ を作ろう】 [創刊号] [最終号]</h1>
        <p class="author">
            <br />
            2024/03/06
        </p>
    </header>

    <div class="abstract">
        <h3>abstract</h3>
        <p>PEGパーサジェネレータを作ります。いろいろな構文解析アルゴリズムの計算量の話もします。</p>
    </div>

    <img src="https://images.dog.ceo/breeds/bluetick/n02088632_419.jpg" alt="ogp" style="width: 100%;">

    <br><br><script>page_contents.push({
    "type":"H2",
    "id":"3",
    "title":"創刊"
});
</script>
<h2 id="3">創刊</h2><br>この前こんな記事を書きました。 <url> <a href="https://www.abap34.com/posts/mini-lang.html">3時間で作る自作言語のJuliaトランスパイラ</a> </url><br><br>この記事では Julia製の PEGパーサジェネレータ <url> <a href="https://github.com/wdebeaum/PEG.jl">PEG.jl</a> </url> を使ってパーサを作りましたが、せっかくPEGを勉強したので自分でも作ってみようと思います。<br><br><script>page_contents.push({
    "type":"H2",
    "id":"15",
    "title":"いろいろな言語の解析の計算量"
});
</script>
<h2 id="15">いろいろな言語の解析の計算量</h2><br>PEG自体は上について説明を書きましたが、パーサジェネレータを作るからには吐かれるパーサのパフォーマンスも気になります。<br>そこで一旦、 いろんな文法で定義された構文の解析の計算量の話をしようと思います。<br><script>page_contents.push({
    "type":"H3",
    "id":"22",
    "title":"1. バックトラックなしの正規言語(表現) の解析 (DFA型の正規表現エンジン)"
});
</script>
<h3 id="22">1. バックトラックなしの正規言語(表現) の解析 (DFA型の正規表現エンジン)</h3><br>形式言語の講義で習うような、定義通りの正規言語(<span class="math-inline"> \( \leftrightarrow \) </span> 正規表現で表現された) 言語 <span class="math-inline"> \( L \) </span> について考えてみると、 入力文字列 <span class="math-inline"> \( S \) </span> の長さを <span class="math-inline"> \( n \) </span> として　毎回 <span class="math-inline"> \( \Theta(n) \) </span> 時間’で  <span class="math-inline"> \( S \in L \) </span> かを判定できます。<br><br>というのも、全ての正規言語に対して対応するDFAが存在するので、これをあらかじめ作っておけば、 <span class="math-inline"> \( n \) </span> ステップで受理できるか判定できるからです。<br><br>実用的には、<span class="math-inline"> \( L \) </span> は正規表現で書かれることが多いでしょうから、DFAの構築自体も考えなければいけません。<br><br>正規表現をNFAに変換するのは正規表現の長さに対して時間・空間ともに線形でできます。<br>DFAにNFAを変換する際はナイーブにやると状態が正規表現の長さに対して指数オーダーになってしまいますが、 遅延評価で必要な状態だけを作ることで正規表現の長さに対して線形時間・空間 + 入力文字列の長さに対しても線形時間・空間で出来ます。<br><br>grepや<url> <a href="https://github.com/google/re2">https://github.com/google/re2</a> </url> などはこうして実装されています。<br><br>というわけで安心─というわけにもいきません。<br><script>page_contents.push({
    "type":"H3",
    "id":"62",
    "title":"2. バックトラックありの正規言語の解析 (VM型の正規表現エンジン)"
});
</script>
<h3 id="62">2. バックトラックありの正規言語の解析 (VM型の正規表現エンジン)</h3><br>世の中で「正規表現」という顔をして提供されている <span class="inline-code"> <code>regex</code> </span> みたいな名前のパッケージたちは 形式言語理論の正規言語の範囲を逸脱した機能が提供されていることが多いです。<br><br>例えば後方参照などは正規文法では表現できません。 Perl が これらの「拡張」正規表現を採用し、 PCREとして広く普及してしまったためにこのような拡張が一般化してしまいました。 (ただ、最初に導入したのは SNOBOL という言語らしいです。)<br><br>では、このような「拡張」正規表現によって表現される言語の解析はどれくらい難しいでしょうか？<br><br>バックトラックが...とか書こうと思ったのですが、そのような記事は結構ある("ReDoS" とかで検索すると出てくる)ので、<br>ここではちょっと面白い結果でおそらく線形時間ではできないだろう、もっと進んで多項式時間まで緩めても できないだろうということを主張したいと思います。<br><br><url> <a href="https://perl.plover.com/NPC/NPC-3SAT.html">Reduction of 3-CNF-SAT to Perl Regular Expression Matching</a> </url> によれば、 Perlの正規表現エンジンは、3SATを解くことが出来ます。 <br>3SAT は NP困難な問題なので、もしこの正規表現が多項式時間で解析できたら  無事に P=NP となります。　<br><br>なので、少なくとも Perlの正規表現を常識的な (?) 多項式時間で解析するアルゴリズムにお目にかかれる日が来るかは怪しいところです。<br>(常識的でなくてもお目にかかれたらすごいですが)<br><br><script>page_contents.push({
    "type":"H3",
    "id":"92",
    "title":"3. 文脈自由言語の解析"
});
</script>
<h3 id="92">3. 文脈自由言語の解析</h3><br>有名なものとして、CYKアルゴリズムがあります。<br><br>これは DPを使って 時間計算量 <span class="math-inline"> \( \Theta(n^3) \) </span> で動作するアルゴリズムです。<br>また、 Earleyアルゴリズムという改良もあります。曖昧でない文脈自由言語に対しては <span class="math-inline"> \( \Theta(n^2) \) </span> で、 一般の文脈自由言語に対しても <span class="math-inline"> \( O(n^3) \) </span> で解析できます。<br><br>とはいえこれでもあまり実用的なパフォーマンスが出にくく、 任意の文脈自由言語に対して高速になるようアルゴリズムを改良するのではなく、<br>解析しやすい性質のいい言語を考える方向性で頑張るという方向性に進んでいったようです。<br><br>この辺の流れは全然体験しておらず、読んだ文章を鵜呑みにしています。歴史とかいずれ調べてみたいです。<br><br>そのため、多くのプログラミング言語などは LALR(1) などで解析できるものになっています。<br>(ということになっていますが実際はあれやこれやと補っていることも多いようです。 例えば C は <span class="inline-code"> <code>typedef</code> </span> 構文の存在によって文脈依存言語になっています。)<br><script>page_contents.push({
    "type":"H2",
    "id":"123",
    "title":"PEG と Packrat Parsing"
});
</script>
<h2 id="123">PEG と Packrat Parsing</h2><script>page_contents.push({
    "type":"H3",
    "id":"125",
    "title":"PEG vs CFG"
});
</script>
<h3 id="125">PEG vs CFG</h3><br>さて、となると気になるのは PEGです。<br>直感的には、文法の表現能力が高いほど解析も難しくなるのではないかという気になるので、PEGの表現能力について考えてみます。<br>まず、有名な話として <span class="math-inline"> \( L = \{ a^n b^n \mid n \geq 0 \} \) </span> は正規言語ではありません。<br>さらに、　<span class="math-inline"> \( L = \{ a^n b^n c^n \mid n \geq 0 \} \) </span> まで行くと文脈自由言語でもありません。<br>そこでこれを PEG で表現できるかを考えてみると、PEG では以下のようにすると <span class="math-inline"> \( L \) </span> が表現できます。<br><div class="code-block"> <pre><code class="language-plaintext">S = &amp;(A !b) a + B
A = a A? b
B = b B? c
</code></pre> </div><br>逆に文脈自由文法では表現できるが、PEGでは表現できないという言語が存在するかは未解決のようです。<br><br>まとめると、PEG は少なくとも文脈自由言語と同等あるいはそれ以上の表現能力を持っていると言えます。<br>したがって、直感的には PEGで書かれた言語の解析は難しそうな気がします。<br><script>page_contents.push({
    "type":"H3",
    "id":"153",
    "title":"(wip) PEG の解析"
});
</script>
<h3 id="153">(wip) PEG の解析</h3><br><br>まず、ナイーブにやると最悪計算量は普通に <span class="math-inline"> \( \Omega(2^n) \) </span> になります。<br>PEGは順序付き選択をサポートしているので、ここでバックトラックが発生してしまうためです。<br>しかし、 解析を進める際に、その時見ている非終端記号と位置をキーにして結果をメモ化しておくだけで、 なんと一挙に <span class="math-inline"> \( O(n) \) </span> が保証されます。<br>これが <span class="strong"> <strong>Packrat Parsing</strong> </span> と呼ばれる手法です。<br><script>page_contents.push({
    "type":"H3",
    "id":"172",
    "title":"Packrat Parsingは本当に効率的？"
});
</script>
<h3 id="172">Packrat Parsingは本当に効率的？</h3><br>さて、かなり劇的な性能改善が起きていて採用待ったなしのように見える Packrat Parsing ですが、 実際これがどれくらい実際のパフォーマンスに影響するかを考えてみます。<br><br>驚くべきことに<span class="strong"> <strong>、「ふつうの」解析の場面では Packrat Parsing はあまり効果を発揮しない</strong> </span> という意見がかなり多いようです。<br><br>まず、一般的に非終端記号の使われる頻度はかなり偏っています。<br>プログラミング言語なら <span class="inline-code"> <code>EXPR</code> </span> などはしょっちゅう使われると思いますが、 例えば <span class="inline-code"> <code>GOTOSTMT</code> </span> などはほとんど使われないと思います。<br><br>さらに、世の中で使われている多くの文法は LALR(1) などで解析できるものでした。<br>たとえ PEG を前提に文法を組み立てても、これらに近い見た目のものを自然と作ることで、 結果的にバックトラックが結果としてあまり発生しない文法になリます。<br><br>これらの理由から、何でもメモ化するとオーバーヘッドが大きくなってかえって非効率になることが多いようです。<br><br>したがって、設計者が指定する、あるいは実際に参照される頻度に基づいて特定の数個の非終端記号に対してのみメモ化を行う というのがよく取られる戦略です。<br><br>(todo: この辺りを実測した結果を載せる)<br><br><br><script>page_contents.push({
    "type":"H2",
    "id":"208",
    "title":"(WIP) PEGパーサジェネレータを作る。 "
});
</script>
<h2 id="208">(WIP) PEGパーサジェネレータを作る。 </h2><br>さて、 本題です。 まずは一旦計算量とかの話は忘れて、素直に意味論に従って PEGパーサジェネレータを作ってみたいと思います。<br><script>page_contents.push({
    "type":"H3",
    "id":"213",
    "title":"デザイン"
});
</script>
<h3 id="213">デザイン</h3><script>page_contents.push({
    "type":"H4",
    "id":"215",
    "title":"サポートする構文"
});
</script>
<h4 id="215">サポートする構文</h4><br>次の構文をサポートすることにします。<br><ul><li>文字列(<span class="inline-code"> <code>PStr</code> </span>)</li><li>正規表現 (<span class="inline-code"> <code>PRegex</code> </span>)</li><li>連接(<span class="inline-code"> <code>PSeq</code> </span>)</li><li>選言(<span class="inline-code"> <code>PChoice</code> </span>)</li><li>否定先読み(<span class="inline-code"> <code>PNot</code> </span>)</li><li>任意文字(<span class="inline-code"> <code>PAny</code> </span>)</li><li>0回以上繰り返し(<span class="inline-code"> <code>PMany</code> </span>)</li></ul><br><span class="inline-code"> <code>PMany</code> </span> や <span class="inline-code"> <code>PRegex</code> </span> は PEG自体には本来ないですが、 記法として便利なので追加します。<br><span class="strong"> <strong><span class="inline-code"> <code>PRegex</code> </span> を正規言語の範囲内で使えば</strong> </span>、これによって表現能力が変わることはありません。<br><script>page_contents.push({
    "type":"H3",
    "id":"260",
    "title":"実装"
});
</script>
<h3 id="260">実装</h3><br>実装していきます。　<br>まずはパースコンテクストを定義します。<br><div class="code-block"> <pre><code class="language-julia">@enum State UN FAIL FINISHED

mutable struct ParseContext
    input::String
    pos::Int
    endpos::Int
    failpos::Int
    state::State
end


function watching(context::ParseContext)
    return SubString(context.input, context.pos, context.endpos)
end
</code></pre> </div><br>ここで、文字列のスライスは allocation が発生するので、これを避けるために <span class="inline-code"> <code>SubString</code> </span> を使います。<br><div class="code-block"> <pre><code class="language-julia">julia&gt; S = randstring(10^6)
&quot;mx ⋯ 999175 bytes ⋯ EA&quot;

julia&gt; @benchmark S[100:10^6-100]
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  14.500 μs … 146.375 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     42.166 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   41.786 μs ±   9.610 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄▃                                ▆█▄▁▁▁ ▁▂▂▃▃▃▃▂▂▁          ▂
  █████▇▇███▅▁▃▃▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███████████████████▇▇▇▆▇▆▇ █
  14.5 μs       Histogram: log(frequency) by time      61.6 μs &lt;

 Memory estimate: 976.50 KiB, allocs estimate: 1.

julia&gt; @benchmark SubString(S, 100, 10^6-100)
BenchmarkTools.Trial: 10000 samples with 893 evaluations.
 Range (min … max):  126.120 ns …  1.929 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     131.205 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   135.445 ns ± 49.261 ns  ┊ GC (mean ± σ):  0.33% ± 2.04%

   ▁▄▂     ▅█▆▄▃▁  ▃▄▃▁                                        ▁
  ▄███▇▅▃▄▄██████▇██████▇▇▇██▇██▆▆▆▆▆▆▅▇█▇█▇▇▇▇▇▅▅▅▅▅▅▅▄▄▄▅▃▄▃ █
  126 ns        Histogram: log(frequency) by time       154 ns &lt;

 Memory estimate: 32 bytes, allocs estimate: 1.
</code></pre> </div><br>ので、パースコンテクストは入力文字列だけ持って、 <span class="inline-code"> <code>SubString</code> </span> を返すようにしておきます。<br><br><span class="inline-code"> <code>startswith</code> </span> とかはもちろん <span class="inline-code"> <code>AbstractString</code> </span> なら使えるので、これで色々実装していきます。<br>例えば <span class="inline-code"> <code>PStr</code> </span> :<br><div class="code-block"> <pre><code class="language-julia">struct PStr &lt;: TerminalExpression
    text::String
end

function match(expr::PStr, context::ParseContext)
    if startswith(watching(context), expr.text)
        newpos = context.pos + length(expr.text)
        return MatchResult(true, expr.text, newpos, newpos)
    else
        return MatchResult(false, nothing, context.pos, context.pos)
    end
end
</code></pre> </div><br><span class="inline-code"> <code>PAny</code> </span>:<br><div class="code-block"> <pre><code class="language-julia">struct PAny &lt;: TerminalExpression end


function match(::PAny, context::ParseContext)
    if context.pos &lt;= context.endpos
        newpos = context.pos + 1
        return MatchResult(true, watching(context)[1], newpos, newpos)
    else
        return MatchResult(false, nothing, context.pos, context.pos)
    end
end
</code></pre> </div><br>完成したものがこちらになります。<br><br><a href="https://github.com/abap34/TinyPEG.jl"><img src="https://gh-card.dev/repos/abap34/TinyPEG.jl.svg"></a><br><br><script>page_contents.push({
    "type":"H2",
    "id":"302",
    "title":"廃刊"
});
</script>
<h2 id="302">廃刊</h2><br>おもしろいです！<br><br><url> <a href="https://gihyo.jp/book/2015/978-4-7741-7270-5">正規表現技術入門</a> </url>  とか、 あるいはもっと実践的な(?) コンパイラとかで使われる話が乗ってる本を読んでみたいなと思いました。<br><br><script>page_contents.push({
    "type":"H2",
    "id":"312",
    "title":"今日の一曲"
});
</script>
<h2 id="312">今日の一曲</h2><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yVWCezwyEsM?si=Tx-kE-6UpcvlPFYb" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><br><br><br><br><br><br><div class="footnote"></div>

    <hr>

    <script src="https://utteranc.es/client.js" repo="abap34/abap34com-comment" issue-term="og:title" label="comment"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>


</html>
