<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
<meta charset="UTF-8">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-10Y7GMS7GV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-10Y7GMS7GV');
    </script>

    <script type="text/javascript" src="//code.typesquare.com/static/ZDbTe4IzCko%253D/ts106f.js"
        charset="utf-8"></script>

    <title> Julia Compiler Internals (02) - Lowering (2) for の linearize </title>

    <meta property="og:title" content="Julia Compiler Internals (02) - Lowering (2) for の linearize">
    <meta property="og:image" content="https://images.dog.ceo/breeds/dachshund/Dash_Dachshund_With_Hat.jpg">
    <meta property="og:description" content="Julia コンパイラの内部実装を調べるシリーズの第2回目です。今回は Lowering における for文の処理について少し書きます。">
    <meta property="og:url" content="https://abap34.com/posts/jci_02.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="abap34's blog">
    <meta property="og:locale" content="ja_JP">

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@abap34" />

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <link rel="stylesheet" href="https://latex.vercel.app/style.css">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.3.2/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ext-language_tools.js"></script>

    <link rel="stylesheet" href="https://latex.vercel.app/prism/prism.css">

    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>


    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        h2 {
            border-bottom: 1px solid #d3d3d3;
            padding-bottom: 0.25em;
        }

        table {
            margin-top: 1em;
            margin-bottom: 1em;
            margin-left: auto;
            margin-right: auto;
        }

        .definition {
            margin-left: 1em;
            margin-right: 1em;
            border: 1px solid #d3d3d3;
            padding: 1em;
        }

        .footnote {
            border-top: 1px solid #d3d3d3;
            margin-top: 2em;
        }
    </style>


    <!-- Runner is not required. Skip this. -->


</head>


<body class="latex-dark-auto">

    <header>
        <h1>Julia Compiler Internals (02) - Lowering (2) for の linearize</h1>
        <p class="author">
            <br />
            2024/09/21
        </p>
    </header>

    <div class="abstract">
        <h3>abstract</h3>
        <p>Julia コンパイラの内部実装を調べるシリーズの第2回目です。今回は Lowering における for文の処理について少し書きます。</p>
    </div>

    <img src="https://images.dog.ceo/breeds/dachshund/Dash_Dachshund_With_Hat.jpg" alt="ogp" style="width: 100%;">

    <br><script>page_contents.push({
    "type":"H2",
    "id":"2",
    "title":"あらすじ"
});
</script>
<h2 id="2">あらすじ</h2><br>Juliaのコンパイラの内部実装を読んでいくシリーズです。<br>シリーズ自体については <url> <a href="https://abap34.com/posts/jci_00.html">第0回</a> </url> を見てください。<br><script>page_contents.push({
    "type":"H2",
    "id":"11",
    "title":"Lowering"
});
</script>
<h2 id="11">Lowering</h2><br><url> <a href="https://abap34.com/posts/jc2_00.html">前回</a> </url> は Lowering について概観しました。<br>今回は、Lowering における for文の処理について少し書きます。<br><script>page_contents.push({
    "type":"H3",
    "id":"19",
    "title":"for の出自"
});
</script>
<h3 id="19">for の出自</h3><br>for はいうまでもなくトップクラスに使われる制御構文ですが、 Juliaにおいては for は以下のような対応の糖衣構文です。<br><div class="code-block"> <pre><code class="language-julia">for i in 1:10
    println(i)
end
</code></pre> </div><br><span class="math-inline"> \( \Leftrightarrow \) </span><br><div class="code-block"> <pre><code class="language-julia">_next = iterate(1:10)
while _next !== nothing
    (i, state) = _next
    println(i)
    _next = iterate(1:10, state)
end
</code></pre> </div><br>(このあたりのことは、 <url> <a href="https://x.com/antimon2">@antimon2</a> </url> さんに教えてもらいました。ありがとうございます。)<br><br><span class="inline-code"> <code>while</code> </span> は前回見たように <span class="inline-code"> <code>compile</code> </span> でバラされていましたが、この糖衣構文を desugar するのはどこでやっているのか見てみます。<br><script>page_contents.push({
    "type":"H3",
    "id":"40",
    "title":"desugar"
});
</script>
<h3 id="40">desugar</h3><br>degugar は <span class="inline-code"> <code>julia-syntax.scm</code> </span> で行われています。<br>例えばわかりやすそうなのでいくと <span class="inline-code"> <code>julia-syntax.scm#L44</code> </span> に<br><div class="code-block"> <pre><code class="language-scheme">;; generate first comparison call, converting e.g. (a &lt; b &lt; c)
;; to ((call &lt; a b) b &lt; c)
(define (compare-one e)
  (let* ((arg   (caddr e))
         (arg2  (if (and (pair? arg)
                         (pair? (cdddr e)))
                    (make-ssavalue) arg)))
    (if (and (not (dotop-named? (cadr e)))
             (length&gt; e 5)
             (pair? (cadddr (cdr e)))
             (dotop-named? (cadddr (cddr e))))
        ;; look ahead: if the 2nd argument of the next comparison is also
        ;; an argument to an eager (dot) op, make sure we don&#39;t skip the
        ;; initialization of its variable by short-circuiting
        (let ((s (make-ssavalue)))
          (cons `(block
                  ,@(if (eq? arg arg2) &#39;() `((= ,arg2 ,arg)))
                  (= ,s ,(cadddr (cdr e)))
                  (call ,(cadr e) ,(car e) ,arg2))
                (list* arg2 (cadddr e) s (cddddr (cdr e)))))
        (cons
         (add-init arg arg2
                   `(call ,(cadr e) ,(car e) ,arg2))
         (cons arg2 (cdddr e))))))
</code></pre> </div><br>とあります。<br>これは <span class="inline-code"> <code>a &lt; b &lt; c</code> </span> という糖衣構文を <span class="inline-code"> <code>(a &lt; b) &lt; c</code> </span> に desugar する処理です。<br>このまま見ていくと <span class="inline-code"> <code>julia-syntax.scm#L1791</code> </span> に 以下のようなものを見つけることができます。<br><br><div class="code-block"> <pre><code class="language-scheme">(define (expand-for lhss itrs body)
  (define (outer? x) (and (pair? x) (eq? (car x) &#39;outer)))
  (let ((copied-vars  ;; variables not declared `outer` are copied in the innermost loop
         ;; TODO: maybe filter these to remove vars not assigned in the loop
         (delete-duplicates
          (filter (lambda (x) (not (underscore-symbol? x)))
                  (apply append
                         (map lhs-vars
                              (filter (lambda (x) (not (outer? x))) (butlast lhss))))))))
    `(break-block
      loop-exit
      ,(let nest ((lhss lhss)
                  (itrs itrs))
         (if (null? lhss)
             body
             (let* ((coll  (make-ssavalue))
                    (next  (gensy))
                    (state (make-ssavalue))
                    (outer (outer? (car lhss)))
                    (lhs   (if outer (cadar lhss) (car lhss)))
                    (body
                     `(block
                       ,@(if (not outer)
                             (map (lambda (v) `(local ,v)) (lhs-vars lhs))
                             &#39;())
                       ,(lower-tuple-assignment (list lhs state) next)
                       ,(nest (cdr lhss) (cdr itrs))))
                    (body
                     (if (null? (cdr lhss))
                         `(break-block
                           loop-cont
                           (soft-let (block ,@(map (lambda (v) `(= ,v ,v)) copied-vars))
                             ,body))
                         `(scope-block ,body))))
               `(block (= ,coll ,(car itrs))
                       (local ,next)
                       (= ,next (call (top iterate) ,coll))
                       ;; TODO avoid `local declared twice` error from this
                       ;;,@(if outer `((local ,lhs)) &#39;())
                       ,@(if outer `((require-existing-local ,lhs)) &#39;())
                       (if (call (top not_int) (call (core ===) ,next (null)))
                           (_do_while
                            (block ,body
                                   (= ,next (call (top iterate) ,coll ,state)))
                            (call (top not_int) (call (core ===) ,next (null))))))))))))
</code></pre> </div><br>ちょっと長いですが、 どうも for を先ほどの while に書き直す処理がなされていることがわかります。<br>なので、 for は<br>desugar → (while として) <span class="inline-code"> <code>compile</code> </span> というながれで AST から linearize されて IR になることがわかりました。<br><br><script>page_contents.push({
    "type":"H2",
    "id":"77",
    "title":"まとめ"
});
</script>
<h2 id="77">まとめ</h2><br>ヤクルト最近ちょっと強いですね〜<br><script>page_contents.push({
    "type":"H2",
    "id":"82",
    "title":"今日の一曲"
});
</script>
<h2 id="82">今日の一曲</h2><br>何かの間違いでヤクルトに入団してほしい。<br><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BtH57Tku3qY?si=aMpxcnxTpfFvwmbf" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><br><div class="footnote"></div>

    <hr>

    <script src="https://utteranc.es/client.js" repo="abap34/abap34com-comment" issue-term="og:title" label="comment"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>


</html>
