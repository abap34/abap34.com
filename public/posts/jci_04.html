<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
<meta charset="UTF-8">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-10Y7GMS7GV"></script>
    <script>
        if (location.hostname !== "localhost") {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());
            gtag('config', 'G-10Y7GMS7GV');
        }
    </script>

    <script type="text/javascript" src="//code.typesquare.com/static/ZDbTe4IzCko%253D/ts106f.js"
        charset="utf-8"></script>

    <title>Julia Compiler Internals (04) - Algorithm of Type Inference [1]</title>

    <!-- OGP / Twitter 用のメタタグ -->
    <meta property="og:title" content="Julia Compiler Internals (04) - Algorithm of Type Inference [1]">
    <meta property="og:image" content="https://abap34.com/posts/jci_04/image-2.png">
    <meta property="og:description" content="Julia の型推論に使われている抽象解釈の理論とアルゴリズムについて考えます。この記事では基本概念と問題設定までを考えます。">
    <meta property="og:url" content="https://abap34.com/posts/jci_04.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="abap34's blog">
    <meta property="og:locale" content="ja_JP">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@abap34" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- ハイライトJS / FontAwesome -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/styles/a11y-light.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/languages/julia.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/languages/julia-repl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/languages/scheme.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/languages/dockerfile.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- その他ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.3.2/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ext-language_tools.js"></script>
    <script type="text/javascript" id="MathJax-script"
            async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <!-- 外部CSSを読み込む (以下が後述の style.css) -->
    <style>/* ===============================================
   Reset / Base
   =============================================== */
*,
*::before,
*::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html,
body {
    width: 100%;
    height: 100%;
    background-color: #fff;
    color: #333;
    font-family: monospace;
    line-height: 1.5;
    /* 文字ちょっと */
    /*  global-header のぶんを押し下げる */
    padding-top: 3.5rem;
    
    /* 長い単語も強制的に改行 */
    word-wrap: break-word;
}

/* ===============================================
      Layout
      =============================================== */
.article-body {
    display: flex;
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 1rem;
    gap: 2rem;
}

.side {
    width: 240px;
    flex-shrink: 0;
}

.side-sticky {
    position: sticky;
    top: 3.5rem;
}

.sidebar {
    padding: 0.5rem;
    max-height: 80vh;
    overflow-y: auto;
}

.content {
    flex: 1;
    padding: 0.5rem;
    min-width: 0;
    /* 内容があふれにくいように */
}

/* ===============================================
      Header
      =============================================== */
/* 一番上に常に固定するヘッダ */
.global-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 999;
    background: #fff;
    border-bottom: 1px solid #ddd;
    padding: 0.5rem 1rem;

    /* 要素は横に並べる */
    display: flex;
    justify-content: space-between;
    align-items: center;

}

.article-header {
    padding: 1rem;
    margin-bottom: 1rem;
    max-width: 800px;
    margin: 0 auto;
}

.title {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
}

.date {
    font-size: 0.9rem;
    color: #777;
    margin-bottom: 0.5rem;
}

.tag-placeholder {
    margin-top: 0.5rem;
}

.tag {
    display: inline-block;
    margin-right: 0.4rem;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    background-color: #eee;
    font-size: 0.8rem;
    color: #333;
}

.tag:hover {
    background-color: #ddd;
}

.tag a {
    color: inherit;
    text-decoration: none;
}

/* ===============================================
      TOC 
      =============================================== */
.toc_title {
    display: none;
}

#toc {
    list-style: none;
    padding-left: 0;
    font-size: 0.9rem;
    color: #555;
    line-height: 1.4;
}

#toc li {
    margin: 0.4rem 0;
}

#toc a {
    text-decoration: none;
    color: #555;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    transition: background-color 0.1s, opacity 0.1s;
    opacity: 1;
}

#toc a:hover {
    background-color: #f0f0f0;
    opacity: 1;
}

#toc a.active {
    background-color: #777;
    color: #fff;
    opacity: 1 !important;
}

/* 階層によるインデント */
.toc_H1 {
    margin-left: 0;
}

.toc_H2 {
    margin-left: 1rem;
}

.toc_H3 {
    margin-left: 2rem;
}

/* ===============================================
      Content
      =============================================== */

/* 見出しの見た目を少し改善し、下線とパディングを追加 */
.content h1,
.content h2,
.content h3,
.content h4,
.content h5,
.content h6 {
    font-weight: bold;
    margin-top: 2rem;
    margin-bottom: 1rem;
    border-bottom: 1px solid #ccc;
    padding-bottom: 0.3rem;
    color: #333;
}

.content p {
    margin-bottom: 1rem;
}

/* インラインコードを本文と区別しやすく */
.content code {
    background-color: #f6f8fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 0.1rem 0.3rem;
    font-size: 0.95em;
}

/* 箇条書きの字下げ */
.content ul,
.content ol {
    margin-left: 1.5rem;
}

/* 画像や動画のはみ出し対策 (特に縦長画像) */
.content img,
.content video {
    max-width: 100%;
    max-height: 80vh;
    /* ビューポートの80%を上限に */
    height: auto;
    display: block;
}


/* コードブロック内の行間を広げ可読性を向上 */
pre code {
    display: block;
    white-space: pre;
    border: none;
    background: none;
    line-height: 1.4;
    margin: 1rem;
}

/* テーブルのデザイン (シンプル＆見やすい) */
table {
    width: 100%;
    border-collapse: collapse;
    /* 余分な隙間を除去 */
    margin: 1rem 0;
    font-size: 0.95rem;
    line-height: 1.4;
    margin: 1rem;
}

table thead th {
    background-color: #f6f8fa;
    border-bottom: 2px solid #ccc;
    padding: 0.6rem 0.8rem;
    text-align: left;
    font-weight: bold;
}

table th,
table td {
    border: 1px solid #ddd;
    padding: 0.5rem 0.8rem;
    vertical-align: top;
}

table tbody tr:nth-child(even) {
    background-color: #f9f9f9;
    /* 偶数行に薄い背景 */
}

table tbody tr:hover {
    background-color: #f0f0f0;
    /* ホバー時の強調 */
}

content a {
    color: #007bff;
    text-decoration: none;
    word-break: break-all;
}

/* ===============================================
      Footer
      =============================================== */
footer {
    margin-top: 2rem;
    text-align: center;
    font-size: 0.8rem;
    color: #666;
}

/* ===============================================
      Responsive
      =============================================== */
@media (max-width: 768px) {
    .article-body {
        flex-direction: column;
        padding: 0 1rem;
    }

    .side {
        width: 100%;
        margin-bottom: 1.5rem;
        /* height: 100vh; を削除、autoに */
        height: auto;
    }

    .content {
        width: 100%;
    }

    iframe {
        width: 100%;
    }
}

/* ===============================================
      Note / Warn / Danger blocks
      =============================================== */
.info {
    background-color: #f0f0f0;
    padding: 1rem;
    border-left: 5px solid #333;
    margin-bottom: 1rem;
}

/* Warn: ちょっと強めの注意喚起 (オレンジ系) */
.warn {
    background-color: #fff3e0;
    /* 薄いオレンジ */
    padding: 1rem;
    border-left: 5px solid #ffa500;
    /* オレンジ */
    margin-bottom: 1rem;
}

/* Danger: 重大な警告 (赤系) */
.danger {
    background-color: #ffe7e7;
    /* 薄い赤 */
    padding: 1rem;
    border-left: 5px solid #ff4d4f;
    /* 赤 */
    margin-bottom: 1rem;
}

/* ===============================================
      Math Blocks (theorem / lemma / corollary / etc.)
      =============================================== */

/* Theorem / Lemma / Corollary / Proposition / Definition / Proof それぞれに共通するベース */
/* ベース: 背景は透明、左に太線のみ */
.theorem,
.lemma,
.corollary,
.proposition,
.definition,
.proof {
    margin-bottom: 1rem;
    padding: 1rem;
    background: none;
    /* 背景色を排除 */
    /* 全部同じスタイルにするなら共通色でもOK。
       個別に変える場合は後で上書きする。 */
    border-left: 4px solid #318f4f;
}

/* Theorem */
.theorem {
    counter-increment: theorem;
    /* 他の色にしたい場合ここで上書き
       border-left-color: #318f4f; */
}

.theorem::before {
    content: "Theorem " counter(theorem) " ";
    font-weight: bold;
    color: #333;
}

/* Lemma */
.lemma {
    counter-increment: lemma;
    /* border-left-color: #318f4f; など */
}

.lemma::before {
    content: "Lemma " counter(lemma) " ";
    font-weight: bold;
    color: #333;
}

/* Corollary */
.corollary {
    counter-increment: corollary;
    border-left-color: #a1314f;
    /* 例: 赤紫系 */
}

.corollary::before {
    content: "Corollary " counter(corollary) " ";
    font-weight: bold;
    color: #333;
}

/* Proposition */
.proposition {
    counter-increment: proposition;
    border-left-color: #c1a131;
    /* 例: 黄土色系 */
}

.proposition::before {
    content: "Proposition " counter(proposition) " ";
    font-weight: bold;
    color: #333;
}

/* Definition */
.definition {
    counter-increment: definition;
    border-left-color: #addef4;
    /* 例: 水色系 */
}

.definition::before {
    content: "Definition " counter(definition) " ";
    font-weight: bold;
    color: #333;
}

/* Proof */
.proof {
    counter-increment: proof;
    border-left-color: #c6e6e5;
    /* 例: 淡いエメラルドグリーン */
}

.proof::before {
    content: "Proof " counter(proof) " ";
    font-weight: bold;
    color: #333;
}

/* 最後の段落が余計な下余白を取らないための調整 */
.theorem p:last-child,
.lemma p:last-child,
.corollary p:last-child,
.proposition p:last-child,
.definition p:last-child,
.proof p:last-child {
    margin-bottom: 0;
}


/* ===============================================
      Footnotes
        =============================================== */

/* 脚注リンクのスタイル */


.footnote-ref {
    font-size: 0.8em;
    vertical-align: super;
    color: #777;
}

.footnote-ref a {
    color: #777;
    text-decoration: none;
}

.footnote-ref a:hover {
    text-decoration: underline;
}

/* 脚注本体のスタイル */
.footnotes {
    margin-top: 1rem;
    padding: 1rem;
    border: 1px solid #ddd;
    font-size: 0.9em;
}

.footnote-def {
    margin-bottom: 0.5rem;
    /* 改行 */
    padding: 0.2rem 0.5rem;
    border-left: 3px solid #ddd;
    display: block;
}

.footnote-def p {
    margin-bottom: 0;
}


</style>

    <!-- テンプレート置換用のスクリプト変数等 -->
    <script>
        page_contents = [];
    </script>

    <!-- Runner is not required. Skip this. -->
</head>

<body>
    <header class="global-header">
        <div class="header-inner">
            <!-- クリックすると sidebar を表示/非表示 -->
            <a href="https://abap34.com" class="header-logo">abap34.com</a> > <a href="https://abap34.com/blog">/blog</a> > <a href="https://abap34.com/posts/jci_04.html">/Julia Compiler Internals (04) - Algorithm of Type Inference [1]</a>
        </div>

        <div class="tweet-button">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button"
               data-text="Julia Compiler Internals (04) - Algorithm of Type Inference [1]" data-url="https://abap34.com/posts/jci_04.html" data-via="@abap34"> Tweet </a>
            <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
        </div>
    </header>

    <div class="article-header">
        <div class="title">Julia Compiler Internals (04) - Algorithm of Type Inference [1]</div>
        <script>title = document.querySelector(".title").innerHTML;</script>
        <br>
        <div class="date">2024/10/21</div>
        <br>
        <div class="tag-placeholder">[JuliaCompilerInternals, Julia, 型推論, コンパイラ, 束論, アルゴリズム, 抽象解釈, データフロー解析]</div>
    </div>

    <!-- 3) コンテンツ本体 (サイドバー + メイン本文) -->
    <div class="article-body">

        <!-- サイドバー (TOC) -->
        <div class="side">
            <div class="side-sticky">
                <div class="sidebar">
                    <ul id="toc"></ul>
                </div>
            </div>
        </div>

        <!-- メイン本文 -->
        <div class="content">
            <br><script>page_contents.push({
    "type":"H2",
    "id":"2",
    "title":"小話"
});
</script>
<h2 id="2">小話</h2><br>@abap34 です。<br>最近は腰と肩がかなり痛いです。いい椅子に座りたい 😢<br>この Julia 処理系を読む会もなんやかんや 2ヶ月くらい毎週続いているのですが、いくつかニュースがあったので本題に入る前に書いておきます！<br><script>page_contents.push({
    "type":"H3",
    "id":"11",
    "title":"ちょっとしたニュース ① "
});
</script>
<h3 id="11">ちょっとしたニュース ① </h3><br>先日 Julia の Co-Founder の <url> <a href="https://en.wikipedia.org/wiki/Jeff_Bezanson">Jeff Bezanson</a> </url> さんが来日されていて、なんとお会いすることができました。<br><br>Twitterのリンクでも貼ろうかと思ったら Wikipedia のページがありました。すごすぎ。<br><br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">It was such an honor to meet <a href="https://twitter.com/JeffBezanson?ref_src=twsrc%5Etfw">@JeffBezanson</a> and fellow Julia compiler enthusiasts in Tokyo! <a href="https://t.co/r1vzPaP0X7">pic.twitter.com/r1vzPaP0X7</a></p>&mdash; abap34 (@abap34) <a href="https://twitter.com/abap34/status/1846208258216022469?ref_src=twsrc%5Etfw">October 15, 2024</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><br><br>そこで 「Julia の処理系を読む会を毎週やっていて、あなたが 10 年前に Scheme で書いたコードをみんなで何時間も読んでいるんです」と伝えたらとても喜んで貰えました！笑<br><br><script>page_contents.push({
    "type":"H3",
    "id":"28",
    "title":"ちょっとしたニュース ②"
});
</script>
<h3 id="28">ちょっとしたニュース ②</h3><br>第5回のコードを読んでいるとき、まだ SSA形式の IR になっていないはずなのに SSA形式の IR にするようなチェックがなされている箇所を見つけ、 「不思議だな〜」と話していたところがあったのですが、今日の記事にも登場する Juliaコンパイラの中の人であるところの aviatesk さんに聞いてみたところ、どうもミス (実際誤った挙動にはならないのでバグというほどでもないですが) っぽいという結論に至りました。<br>読み始めたときにバグの一つや二つでも見つけられたらいいな〜と思っていたのでこれは嬉しいです。<br>追伸: 修正のPRが作られて、マージされました。 <url> <a href="https://github.com/JuliaLang/julia/pull/56314">https://github.com/JuliaLang/julia/pull/56314</a> </url><br><br>いろいろといいことが起きてていい感じですね。今後も頑張っていきます！<br><br><hr><br><br><script>page_contents.push({
    "type":"H2",
    "id":"45",
    "title":"あらすじ"
});
</script>
<h2 id="45">あらすじ</h2><br>今回もJuliaのコンパイラの内部実装を読んでいくシリーズです。<br>シリーズ自体については <url> <a href="https://abap34.com/posts/jci_00.html">第0回</a> </url> を見てください。<br><br><url> <a href="https://abap34.com/posts/jci_03.html">前回</a> </url> は Julia の型推論について概観しました。<br><br>今回は実際にアルゴリズムに踏み込んでいきます。<br>具体的には、一旦 Julia のソースコードから離れて aviatesk さんの記事 <url> <a href="https://zenn.dev/aviatesk/articles/data-flow-problem-20201025">Juliaの型推論アルゴリズムを実装する</a> </url> を読んで実装しようと思います。 (以下 「元記事」とかきます)<br><br>この記事はなるべく元記事の理解の補足になることを目指しています。<br>少し長くなりそうなので 2,3 個に分ける予定です。<br><br>まず今回は前提知識や問題設定などについて書きます。<br><br>(※ この記事の執筆は aviatesk さんの許諾をいただいて行われています。ありがとうございます！)<br><br><script>page_contents.push({
    "type":"H2",
    "id":"77",
    "title":"束 (Lattice) の定義と具体例"
});
</script>
<h2 id="77">束 (Lattice) の定義と具体例</h2><br>少しだけ使う概念の準備を書いておきます。<br><div class="definition"><span class="strong"> <strong>束 (Lattice)</strong> </span><br><br>集合 <span class="math-inline"> \( L \) </span> と <span class="math-inline"> \( L \) </span> 上の二項関係 <span class="math-inline"> \( \leq \) </span> が以下の条件を満たすとき、<span class="math-inline"> \( (L, \leq) \) </span> を束であるという。<br><ol><li><span class="math-inline"> \( \leq \) </span> が半順序である</li><li>各 <span class="math-inline"> \( x, y \in L \) </span> について <span class="math-inline"> \( \{ x, y \} \) </span> の上限と下限が常に存在する</li></ol><br>とくに <span class="math-inline"> \( L \) </span> が有限集合のとき、有限束という。</div><br><div class="definition"><span class="strong"> <strong>交わり(meet), 結び(join)</strong> </span><br><br>束 <span class="math-inline"> \( (L, \leq) \) </span> について、<br><ul><li><span class="math-inline"> \( x, y \in L \) </span> に対して <span class="math-inline"> \( \inf \{ x, y \} \) </span> を <span class="math-inline"> \( x \) </span> と <span class="math-inline"> \( y \) </span> の交わり (meet)</li><li><span class="math-inline"> \( x, y \in L \) </span> に対して <span class="math-inline"> \( \sup \{ x, y \} \) </span> を <span class="math-inline"> \( x \) </span> と <span class="math-inline"> \( y \) </span> の結び (join)</li></ul><br>という。</div><br>これだけだとパッとわかりにくいので、具体例を挙げてみます。<br><script>page_contents.push({
    "type":"H3",
    "id":"147",
    "title":"束の例1: 論理関数"
});
</script>
<h3 id="147">束の例1: 論理関数</h3><br>束は割と色々なところに現れる構造です。<br><br>例えば、自分は論理回路理論の講義で束に出会いました。調べたらあまり例に上がっていなかったのと、この記事のメインと構造が同じことに気がついたのででここで書いてみます。<br><br><span class="math-inline"> \( \mathbb{B} = \{ \text{0}, \text{1} \} \) </span> として、 (<span class="math-inline"> \( \text{0} \leq \text{1} \) </span> です) <br><span class="math-inline"> \( \mathbb{B}^n \to \mathbb{B} \) </span> な関数全体の集合を <span class="math-inline"> \( \mathcal{F} \) </span> とします。<br><span class="math-inline"> \( f, g \in \mathcal{F} \) </span> に対して次のように <span class="math-inline"> \( \mathcal{F} \) </span> 上の二項関係 <span class="math-inline"> \( \leq \) </span> を定義しましょう:<br><div class="math-block"> \[ 

f \leq g \Leftrightarrow \forall x \in \mathbb{B}^n, f(x) \leq g(x)

 \] </div><br>このとき <span class="math-inline"> \( (\mathcal{F}, \leq) \) </span> は束です。<br>確認してみます。<br><ol><li><span class="math-inline"> \( \leq \) </span> が半順序であること: これは一つずつ確認すると、それはそうです</li><li><span class="math-inline"> \( f, g \in \mathcal{F} \) </span> に対して、<span class="math-inline"> \( \{ f, g \} \) </span> の上限と下限が存在すること: <span class="math-inline"> \( h(x) := \max \{ f(x), g(x) \} \) </span> とすると、これは上限です。 <span class="math-inline"> \( h(x) := \min \{ f(x), g(x) \} \) </span> とすると、これは下限です。</li></ol><br>実際、例えば <span class="math-inline"> \( \mathbb{B} \to \mathbb{B} \) </span> の関数全体の集合は<br><br><table>
<thead>
<tr>
<th align="left"> <span class="math-inline"> \( x \) </span>  </th>
<th align="left"> <span class="math-inline"> \( f(x) \) </span> </th>
<th align="left"> <span class="math-inline"> \( g(x) \) </span> </th>
<th align="left"> <span class="math-inline"> \( h(x) \) </span> </th>
<th align="left"> <span class="math-inline"> \( l(x) \) </span> </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> 0    </td>
<td align="left"> 0      </td>
<td align="left"> 0      </td>
<td align="left"> 1      </td>
<td align="left"> 1      </td>
</tr>
<tr>
<td align="left"> 1    </td>
<td align="left"> 0      </td>
<td align="left"> 1      </td>
<td align="left"> 0      </td>
<td align="left"> 1      </td>
</tr>
</tbody>
</table>
<br><br>からなるわけですが、<br>以下のような図でその束の構造を表すことができます。<br><div class="code-block"> <pre><code class="language-plaintext">     l
     /\
    /  \
   /    \
  /      \
 h        g
  \      /
   \    /
    \  /
     \/
     f
</code></pre> </div><br>つまり、ふんわり言うと束は上のような上下関係をいい感じの図にしたときに、どれをとっても下か上に辿れば交わるものと言えます。 (このような図を Hasse 図と言います。なお、全ての束が Hasse 図で表せるわけではないです  (例えば <span class="math-inline"> \( \mathbb{R} \) </span> と通常の大小関係))<br>なのでこういうグラフが得られているのであれば  <span class="math-inline"> \( \inf \{a, b\} \) </span> と <span class="math-inline"> \( \sup \{a, b\} \) </span> を求めるのは LCA を求める問題に帰着します。<br><br><br><script>page_contents.push({
    "type":"H3",
    "id":"261",
    "title":"束の例2: Julia の型"
});
</script>
<h3 id="261">束の例2: Julia の型</h3><br>Julia の型と、その親子関係による順序関係も束をなします。<br><span class="math-inline"> \( L \) </span> を Julia の型全体の集合とし、<br><span class="math-inline"> \( L = \{ \text{Any}, \text{Number}, \text{Real}, \text{Int64} \cdots \} \) </span> <br><br>二項関係 <span class="math-inline"> \( \leq \) </span> を次のように定義します:<br><span class="math-inline"> \( T \leq U \Leftrightarrow \) </span> 型 <span class="math-inline"> \( T \) </span> が型 <span class="math-inline"> \( U \) </span> のサブタイプである<br><br>このとき <span class="math-inline"> \( (L, \leq) \) </span> は束になります。<br>上に載せた図を作ることで直感的に確認しておきましょう、 「Julia Type Tree」 とかで検索するといい感じの図が出てきます。<br><figure><img src="jci_04/image.png" ><figcaption>https://stackoverflow.com/questions/71524602/visualize-the-julia-type-tree より</figcaption></figure><br>おかしいです！ 束であるためには任意の 2つの元について下限が必要ですから、枝分かれのある木な訳がないです。<br><br>しかし Julia の Concrete Type は サブタイプを持たないはずです。どう言うことでしょうか？<br><br>──実は Julia の Concrete Type にサブタイプが存在しないと言うのが誤りで、 <span class="inline-code"> <code>Union{}</code> </span> 型と言う型が存在してこれは任意の型のサブタイプになります。<br>(<span class="inline-code"> <code>Union{}</code> </span> のオブジェクトは存在しません。型としてのみ存在します。)<br><br><div class="code-block"> <pre><code class="language-julia-repl">julia&gt; Union{} &lt;: Any
true

julia&gt; Union{} &lt;: Int64
true
</code></pre> </div><br>したがって、任意の Concrete Type <span class="math-inline"> \( T, U \) </span> に対して <span class="math-inline"> \( \inf \{ T, U \} = \text{Union\{\}} \) </span> となります。<br>この型の存在によって Julia の型の階層関係は束をなします。<br><script>page_contents.push({
    "type":"H3",
    "id":"318",
    "title":"高さの有限性"
});
</script>
<h3 id="318">高さの有限性</h3><br>また、 Juliaの型の階層関係はこの記事で今後扱っていくアルゴリズムにおいて重要な以下の性質を満たしています。 (多分)<br>ここで導入しておきます。<br><br><div class="definition"><span class="strong"> <strong>鎖 (Chain)</strong> </span><br>集合 <span class="math-inline"> \( L \) </span> と <span class="math-inline"> \( L \) </span> 上の二項関係 <span class="math-inline"> \( \leq \) </span> を考える.<br>ここで、 <span class="math-inline"> \( P \subseteq L \) </span> が任意の <span class="math-inline"> \( x, y \in P \) </span> に対して <span class="math-inline"> \( x \leq y \) </span> または <span class="math-inline"> \( y \leq x \) </span> となるとき、 <span class="math-inline"> \( P \) </span> を<span class="strong"> <strong>鎖</strong> </span>といい、 <span class="math-inline"> \( |P| - 1 \) </span> を鎖の<span class="strong"> <strong>長さ</strong> </span>という。 <br></div><br><br><div class="definition"><span class="strong"> <strong>高さ</strong> </span><br>最小元 <span class="math-inline"> \( \bot \) </span> が存在する半順序集合 <span class="math-inline"> \( (L, \leq) \) </span> の元 <span class="math-inline"> \( x \) </span> に対して、 <span class="math-inline"> \( [ \bot, x ] \subseteq L \) </span> の鎖の長さの最大値を <span class="math-inline"> \( x \) </span> の<span class="strong"> <strong>高さ</strong> </span>という。<br>さらに、 <span class="math-inline"> \( L \) </span> の元の高さの最大値を <span class="strong"> <strong>Lの高さ</strong> </span> という。<br></div><br>例えば<br><div class="math-block"> \[ 

\{ \text{Any}, \text{Number}, \text{Real}, \text{Int64} \}

 \] </div><br>などは鎖で、長さは 3 です。<br>また、先ほど挙げた論理関数全体の集合がなす束の高さは 2 です。<br><br>今の自分の理解では Julia の型の階層構造の高さは有限です。<br>(※ 仕様を読んだり示したりしたわけではなく、そう思っているだけなのでご存じの方がいたら教えてください)<br><br><hr><br>さて、このように束は割といろんなところに現れる構造っぽいです。<br>そして、実はプログラムのさまざまな要素・状態を束で表現することでいろいろな性質の解析ができます。<br>ここからはそれを具体的に見ていきます。<br><script>page_contents.push({
    "type":"H2",
    "id":"411",
    "title":"抽象解釈"
});
</script>
<h2 id="411">抽象解釈</h2><br>Julia の型推論アルゴリズムは抽象解釈と呼ばれる手法を使っています。<br>そこで、まずは 一旦 Julia の型推論のことは忘れて一般の抽象解釈についての話をしましょう。<br><br>まず前提として、プログラムの調べたい性質は大抵の場合 Undecidable で、静的解析をするには常に諦めもしくはある程度の抽象化が必要になります。<br><br>そこで、抽象解釈は読んで字の如し、プログラムをある程度抽象化して仮想的に実行することで、プログラムの性質を解析します。 つまり、抽象解釈という言葉は具体的なアルゴリズムというより、ある種のアプローチというかフレームワークというかを指す言葉です。<br>この抽象化の程度や方向性によって色々な解析をやっていくわけです。 例えば (役に立つのかはともかく、) 変数の偶奇だけに着目して「偶奇だけがわかるレベルで」プログラムを解釈して静的に偶奇の情報を得る、などができます。<br><br>元記事では定数畳み込みを抽象解釈を使って行っています。この記事でもまずはこの例を検討してみます。<br><script>page_contents.push({
    "type":"H3",
    "id":"429",
    "title":"抽象解釈による定数畳み込み: 問題設定"
});
</script>
<h3 id="429">抽象解釈による定数畳み込み: 問題設定</h3><br>以下のような機能を持つ簡単な言語を考えます。<br><br><ul><li>代入: <span class="inline-code"> <code>x := 1</code> </span>, <span class="inline-code"> <code>r := y + z</code> </span></li><li>goto: <span class="inline-code"> <code>goto line</code> </span></li><li>条件つき goto: <span class="inline-code"> <code>if x &lt; 10 goto inst</code> </span>, <span class="inline-code"> <code>if x ≤ z goto inst</code> </span></li></ul><br>簡単のために、代入の右辺は定数か変数またはそれらの二項演算のみで、値は全て整数とします。<br>例えば以下のような感じです。 <br><div class="code-block"> <pre><code class="language-plaintext">0 ─ I₀ = x := 1
│   I₁ = y := 2
│   I₂ = z := 3
└── I₃ = goto I₈
1 ─ I₄ = r := y + z
└── I₅ = if x ≤ z goto I₇
2 ─ I₆ = r := z + y
3 ─ I₇ = x := x + 1
4 ─ I₈ = if x &lt; 10 goto I₄
</code></pre> </div><br><details> <summary>左についている枠について</summary><br>命令列の左に枠がついていますが、これは基本ブロック (Basic Block) というものです。 基本ブロックは、文の列であって、分岐も合流もない、つまり一つの入り口と一つの出口を持つものをいいます。<br>これによってプログラム全体の流れを表したものを制御フローグラフ (Control Flow Graph) と言います。<br>プログラムが直列化されていれば goto, 条件付き goto によって分割することでこれが得られます。 (Julia では Lowering によってこれがされているんでした！このシリーズの過去記事を見てください。) </details><br>じっと見ると、以下のような処理をしていることがわかります。<br><div class="code-block"> <pre><code class="language-julia">x = 1
y = 2
z = 3

while x &lt; 10
     r = y + z
     if !(x ≤ z)
         r = z + y
     end   
     x += 1

     # @show x, y, z, r
end
</code></pre> </div><br>手で実行してみると、こんな感じです.<br><br><table>
<thead>
<tr>
<th align="left"> step </th>
<th align="left"> <span class="math-inline"> \( I \) </span> </th>
<th align="left"> <span class="math-inline"> \( x \) </span> </th>
<th align="left"> <span class="math-inline"> \( y \) </span> </th>
<th align="left"> <span class="math-inline"> \( z \) </span> </th>
<th align="left"> <span class="math-inline"> \( r \) </span> </th>
<th align="center">  </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> 0 </td>
<td align="left"> <span class="math-inline"> \( I_0 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> - </td>
<td align="left"> - </td>
<td align="left"> - </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 1 </td>
<td align="left"> <span class="math-inline"> \( I_1 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> 2 </td>
<td align="left"> - </td>
<td align="left"> - </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 2 </td>
<td align="left"> <span class="math-inline"> \( I_2 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> - </td>
<td align="center"> </td>
</tr>
<tr>
<td align="left"> 4 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> - </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 5 </td>
<td align="left"> <span class="math-inline"> \( I_4 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 6 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 1 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x \leq z \) </span> なので <span class="math-inline"> \( I_7 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 7 </td>
<td align="left"> <span class="math-inline"> \( I_7 \) </span> </td>
<td align="left"> 2 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 8 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 2 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 9 </td>
<td align="left"> <span class="math-inline"> \( I_4 \) </span> </td>
<td align="left"> 2 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 10 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 2 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x \leq z \) </span> なので <span class="math-inline"> \( I_7 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 11 </td>
<td align="left"> <span class="math-inline"> \( I_7 \) </span> </td>
<td align="left"> 3 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 12 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 3 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 13 </td>
<td align="left"> <span class="math-inline"> \( I_4 \) </span> </td>
<td align="left"> 3 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 14 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 3 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x \leq z \) </span> なので <span class="math-inline"> \( I_7 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 15 </td>
<td align="left"> <span class="math-inline"> \( I_7 \) </span> </td>
<td align="left"> 4 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 16 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 4 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 17 </td>
<td align="left"> <span class="math-inline"> \( I_4 \) </span> </td>
<td align="left"> 4 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 18 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 4 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x \leq z \) </span> ではないのでジャンプはしない </td>
</tr>
<tr>
<td align="left"> 19 </td>
<td align="left"> <span class="math-inline"> \( I_6 \) </span> </td>
<td align="left"> 4 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 20 </td>
<td align="left"> <span class="math-inline"> \( I_7 \) </span> </td>
<td align="left"> 5 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 21 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 5 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> 22 </td>
<td align="left"> <span class="math-inline"> \( I_4 \) </span> </td>
<td align="left"> 5 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 23 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 5 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x \leq z \) </span> ではないのでジャンプはしない </td>
</tr>
<tr>
<td align="left"> 24 </td>
<td align="left"> <span class="math-inline"> \( I_6 \) </span> </td>
<td align="left"> 5 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 25 </td>
<td align="left"> <span class="math-inline"> \( I_7 \) </span> </td>
<td align="left"> 6 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center">  </td>
</tr>
<tr>
<td align="left"> 26 </td>
<td align="left"> <span class="math-inline"> \( I_8 \) </span> </td>
<td align="left"> 6 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> なので <span class="math-inline"> \( I_4 \) </span> にジャンプ </td>
</tr>
<tr>
<td align="left"> ... </td>
<td align="left"> ... </td>
<td align="left"> ... </td>
<td align="left"> ... </td>
<td align="left"> ... </td>
<td align="left"> ... </td>
<td align="center"> ... </td>
</tr>
<tr>
<td align="left"> 45 </td>
<td align="left"> <span class="math-inline"> \( I_5 \) </span> </td>
<td align="left"> 10 </td>
<td align="left"> 2 </td>
<td align="left"> 3 </td>
<td align="left"> 5 </td>
<td align="center"> <span class="math-inline"> \( x < 10 \) </span> でないのでジャンプはしない. 終了 </td>
</tr>
</tbody>
</table>
<br><br><span class="inline-code"> <code>x</code> </span> をループカウンタとして使いつつ、最後の <span class="inline-code"> <code>10 - z</code> </span> 回は <span class="inline-code"> <code>r = z + y</code> </span> もする、みたいなコードです (これは何？)<br><br>さて、ここから以下の事実を静的解析によって見つけることが目標です:<br><br><div style="text-align: center;"><br><span class="strong"> <strong><span class="inline-code"> <code>y</code> </span>, <span class="inline-code"> <code>z</code> </span>, <span class="inline-code"> <code>r</code> </span> は定数である</strong> </span><br></div><br><script>page_contents.push({
    "type":"H3",
    "id":"1009",
    "title":"データフロー解析の形式的定義"
});
</script>
<h3 id="1009">データフロー解析の形式的定義</h3><br>このあと具体的なアルゴリズムに入る前に、もう少し解こうとしている問題をもう少し一般化して定式化してみます。<br>今回解きたい問題は、以下のように定義される 「データフロー解析」 と呼ばれる抽象解釈によって解ける問題の一つとして捉えることができます。<br><br>データフロー解析は、簡単に言えば次のような問題を解くことです。<br><ul><li><span class="strong"> <strong>命令 <span class="math-inline"> \( i \) </span> の直前/直後の抽象状態として、最も具体的なものを求めよ。</strong> </span></li></ul><br>実際に計算機上で解くために、形式的に定義してみましょう。<br><br><div class="definition"><span class="strong"> <strong>データフロー解析 (Data Flow Analysis)</strong> </span><br><br>命令全体の集合を <span class="math-inline"> \( \text{Instr} \) </span> 、プログラムの状態全体の集合を <span class="math-inline"> \( A \) </span> とする。<br><span class="math-inline"> \( \text{Instr} \) </span> は <br><ul><li>代入 </li><li>goto</li><li>条件つき goto</li></ul><br>のいずれかに属する命令の集合。<br><br>ここで、以下のような四つ組 <span class="math-inline"> \( (P, L, ![.!], a_0) \) </span> を考える:<br><ul><li><span class="math-inline"> \( P = I_1, I_2, \cdots, I_n \in \text{Instr} \) </span>: プログラム (命令の有限列)</li><li><span class="math-inline"> \( L = (A, \leq) \) </span>: 高さが有限の束</li><li><span class="math-inline"> \( ![.!] \in \text{Instr} \to (A \to A) \) </span>: 各命令の作用を表す単調関数を返す関数 </li><li><span class="math-inline"> \( a_0 \in A \) </span>: 初期状態</li></ul><br>このとき、データフロー解析は以下のような問題を解くことである:<br><span class="math-inline"> \( \text{Pred}_P: \{1, 2, \cdots, n\} \to 2^{\{1, 2, \cdots, n\}} \) </span> を<br><div class="math-block"> \[ 

j \in \text{Pred}_P(i) \Leftrightarrow 
I_j \in \{ \text{goto i}, \text{条件つき goto i} \} \text{ または } j = i - 1  \ かつ\  I_i \neq \text{goto}

 \] </div><br>と定めたとき、連立方程式<br><div class="math-block"> \[ 

s_i = \prod_{j \in \text{Pred}_P(i)} ![I_j!](s_j) \quad (i = 1, 2, \cdots, n) 

 \] </div><br>を満たす最大の解 <span class="math-inline"> \( s_1, s_2, \cdots, s_n \) </span> を求めよ<br></div><br>少し補足をします。<br><ul><li>状態 <span class="math-inline"> \( s \in A \) </span> のときに 命令 <span class="math-inline"> \( I \) </span> を実行したときの状態は <span class="math-inline"> \( ![I!](s) \) </span> です (記法の確認です)</li><li><span class="inline-code"> <code>\bigsqcap</code> </span> が MathJax で使えなかったので <span class="math-inline"> \( \prod \) </span> で代用しています。交わりの意味です。</li><li>つまり、 連立方程式の各方程式はつまるところ「ありうる直前命令からの実行結果の全ての交わり」と言うことになります。</li><li><span class="math-inline"> \( \text{Pred}_P(i) \) </span> はややこしくなっていますが、要は命令 <span class="math-inline"> \( I_i \) </span> の直前になりうる命令のインデックスの集合になります。</li><ul><li>果たしてこれは最初に書いた「命令 <span class="math-inline"> \( i \) </span> の直前/直後の抽象状態として、最も具体的なものを求めよ」に対応する妥当な定義でしょうか？実はとても議論の余地、というか抜けがあります。次回の記事で議論するので、一旦ここは置いておいてください。</li></ul><li>元記事や <url> <a href="https://www.semanticscholar.org/paper/A-Graph-Free-Approach-to-Data-Flow-Analysis-Mohnen/5ad8cb6b477793ffb5ec29dde89df6b82dbb6dba?p2df">元論文</a> </url> では <span class="math-inline"> \( L \) </span> を その交わりと結びで定義していますが、ここでは準備に合わせて <span class="math-inline"> \( (A, \leq) \) </span> としています。</li><li>順序関係が <span class="math-inline"> \( A \) </span> 上で定まっていることに注意しましょう。 (後述します)</li></ul><br><br><script>page_contents.push({
    "type":"H3",
    "id":"1131",
    "title":"定数畳み込みの形式的定義"
});
</script>
<h3 id="1131">定数畳み込みの形式的定義</h3><br>実際に今回の問題をこの定義に落とし込みます。<br><br>上から行きましょう。<br><script>page_contents.push({
    "type":"H4",
    "id":"1139",
    "title":"1. <span class="math-inline"> \( \text{Instr} \) </span>"
});
</script>
<h4 id="1139">1. <span class="math-inline"> \( \text{Instr} \) </span></h4><br>ちゃんと定義したければ BNF とかを書けばいいと思いますがいったんふわっと書くと<br><div class="math-block"> \[ 

\begin{align*}
\text{Instr} =\  &\{ \\
&x := 1, \\
&x := 1 + y, \\
&\text{goto 1}, \\
&\text{if } x < 10 \text{ goto 2}, \\
&\vdots \\
\}
\end{align*}

 \] </div><br>みたいな集合です。全ての要素はそれぞれ 代入, goto, 条件つき goto のどれかただ一つに属することに注意してください。<br>代入文の右辺には定数、変数またはそれらの二項演算がきます。(<span class="math-inline"> \( n \) </span> 項演算に拡張するのは容易ですが説明のために簡単にしています)<br><script>page_contents.push({
    "type":"H4",
    "id":"1153",
    "title":"2. <span class="math-inline"> \( A, \leq \) </span>"
});
</script>
<h4 id="1153">2. <span class="math-inline"> \( A, \leq \) </span></h4><br>次はプログラムの状態 <span class="math-inline"> \( A \) </span> とその順序関係 <span class="math-inline"> \( \leq \) </span> です。<br>今回の設定では変数の状態以外に特に状態はありませんから、<br><span class="math-inline"> \( X \) </span> を変数の集合、 <span class="math-inline"> \( C \) </span> を変数の状態の集合として<br><span class="math-inline"> \( A = X \to C \) </span> とすればいいでしょう。<br><br>今さらっと <span class="math-inline"> \( C \) </span> を導入しましたが、ここが (多分自分が思うに) キモです。 これの中身をどうするかが抽象解釈の設計の本質パート (ではないかとと素人ながら) 思います.<br><br>というのもこの部分こそが調べたい性質のためにプログラムを抽象化するパートだからです。<br><br>例えば今回の場合、次のような集合と順序関係を考えることによって抽象化します。<br><br><span class="math-inline"> \( L = \{ \bot, 1, 2, 3, \cdots, \top \} \) </span> として、 <span class="math-inline"> \( L \) </span> 上の順序関係 <span class="math-inline"> \( \leq \) </span> を次のように定義します:<br><div class="math-block"> \[ 

l_i \leq l_j \Leftrightarrow l_i = l_j \text{ または } l_i = \bot \text{ または } l_j = \top

 \] </div><br>このとき <span class="math-inline"> \( (L, \leq) \) </span> は束です。 <br><br>図にすると<br><figure><img src="jci_04/image-1.png" ><figcaption>元記事より</figcaption></figure><br>みたいな感じです。<br><span class="math-inline"> \( \bot, \top \) </span> はそれぞれ次のような意味です。 <span class="footnote-ref"><sup id="ref_1"><a href="#label_1">[1]</a></sup></span><br><ul><li><span class="math-inline"> \( \bot \) </span>: 定数でない</li><li><span class="math-inline"> \( \top \) </span>: 未定義</li></ul><br><br>このような状態 <span class="math-inline"> \( C \) </span> を設定することで、実際の実行から、「定数かどうか && 定数ならその値」を考える抽象的な解釈に落とし込まれるわけです！ (たぶん)<br><br>例えば (そんなもんが役に立つのかはさておき) 単に「定数かどうか」だけ調べるのであれば <span class="math-inline"> \( C = \{ \bot, c, \top \} \) </span>  みたいな感じでいいのだと思います。<br><br>なお、注意する点として、 <span class="strong"> <strong>データフロー解析の問題設定においてはあくまでも束をなのは 各変数でなく状態 <span class="math-inline"> \( A \) </span> と <span class="math-inline"> \( A \) </span> 上の順序です。</strong> </span><br>したがって <span class="math-inline"> \( A \) </span> 上の順序関係を考える必要があります。<br>が、そこまで大変でなく単に次のようにすればいいです。<br><div class="math-block"> \[ 

a_i \leq a_j \Leftrightarrow \forall x \in X, a_i(x) \leq a_j(x)

 \] </div><br>これが束をなすのは論理関数のときと同じような感じでわかります！　(一般に、束の直積は上のように順序関係を定義することで束になります)<br>なお、次の記事で使うのでここでいくつかメモ書きをしておきます。 (また、これ以降では記法の煩雑さ回避のために全ての変数が共通の状態 <span class="math-inline"> \( l \) </span> である抽象状態 <span class="math-inline"> \( C: X \mapsto l \) </span> を単に <span class="math-inline"> \( l \) </span> と書きます.)<br><ol><li>meet の単位元は <span class="math-inline"> \( \bot \) </span> です</li><li>join の単位元は <span class="math-inline"> \( \top \) </span> です</li><li><span class="math-inline"> \( C \) </span> は有限性条件を満たします. (長さが最大の鎖は <span class="math-inline"> \( \bot \leq c \leq \top \) </span> です)</li></ol><br><script>page_contents.push({
    "type":"H4",
    "id":"1272",
    "title":"3. <span class="math-inline"> \( ![.!] \) </span>"
});
</script>
<h4 id="1272">3. <span class="math-inline"> \( ![.!] \) </span></h4><br>構文は 3種類に分かれているわけですが、それぞれについて考えればいいです。<br>[代入]<br><span class="inline-code"> <code>x := expr</code> </span> としたとき、 <span class="math-inline"> \( x \) </span> 以外の変数の状態は変わりません。<br>右辺に現れるのが全て定数( <span class="math-inline"> \( \neq \bot \) </span>) であれば <span class="inline-code"> <code>x</code> </span> も定数になりますから、  <span class="math-inline"> \( s' = ![\text{var} := \text{expr}!](s) \) </span> は次のようになります。<br><br><div class="math-block"> \[ 

a = 
\begin{cases}
\text{expr} & \text{右辺がすべて定数} \\
\bot & \text{otherwise}
\end{cases}

 \] </div><br>として、<br><div class="math-block"> \[ 

s'(x) = \begin{cases}
\text{a} & x = \text{\text{var}} \\
s(x) & \text{otherwise}
\end{cases}

 \] </div><br><br>[goto]<br>何も変わらないです。<br><br>[条件つき goto]<br>何も変わらないです。<br><br><script>page_contents.push({
    "type":"H4",
    "id":"1311",
    "title":"4. <span class="math-inline"> \( a_0 \) </span>"
});
</script>
<h4 id="1311">4. <span class="math-inline"> \( a_0 \) </span></h4><br>初期状態は全ての変数が <span class="math-inline"> \( \top \) </span> です。 元記事によれば元論文が間違っているとのことです。自分が一から読んでいたら気がつけないだろうことなので、ありがたいです。。。<br><br><script>page_contents.push({
    "type":"H2",
    "id":"1320",
    "title":"まとめ ！？"
});
</script>
<h2 id="1320">まとめ ！？</h2><br>こうして今回の問題設定をデータフロー解析の形式的定義に落とし込むことができました。<br><br>次回は実際にこれを解くアルゴリズムを紹介します。<br><br><script>page_contents.push({
    "type":"H2",
    "id":"1329",
    "title":"今日の一曲"
});
</script>
<h2 id="1329">今日の一曲</h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/D0W44Z3D3wo?si=kvQ68VsF5tg-C5lC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><br><div class="footnote"><span class="footnote-def" id="label_1"><a href="#ref_1">[1]</a> 分野によって入れ替わることもあるみたいです。 <url> <a href="https://x.com/__pandaman64__/status/1321404812332654592">参考</a> </url></span></div>
            <hr>
            <!-- コメント欄 (Utterances) -->
            <script src="https://utteranc.es/client.js"
                    repo="abap34/abap34com-comment"
                    issue-term="og:title"
                    label="comment"
                    theme="github-light"
                    crossorigin="anonymous"
                    async>
            </script>
        </div>

        <footer>
            <p>&copy; abap34</p>
        </footer>
    </div>

    <!-- 4) TOC 自動生成スクリプトなど -->
    <script>
        const tocContainer = document.querySelector("#toc");
        const tocTitle = document.createElement("div");
        tocTitle.innerHTML = title;
        tocTitle.classList.add("toc_title");
        tocContainer.appendChild(tocTitle);

        // TOC 要素生成
        page_contents.forEach(item => {
            if (item.type == "H1" || item.type === "H2" || item.type === "H3") {
                const listItem = document.createElement("li");
                listItem.innerHTML = `<a href="#${item.id}">${item.title}</a>`;
                listItem.classList.add("toc_" + item.type);
                tocContainer.appendChild(listItem);
            }
        });

        // IntersectionObserver でスクロール時に active 更新
        const options = {
            root: null,
            rootMargin: "-50% 0px",
            threshold: 0
        };
        const observer = new IntersectionObserver(onIntersection, options);

        page_contents.forEach(item => {
            const element = document.getElementById(item.id);
            if (element) observer.observe(element);
        });

        const first_item = document.querySelector(`#toc a[href="#${page_contents[0].id}"]`);
        first_item.classList.add("active");
        let prev_item = first_item;

        function onIntersection(entries) {
            entries.forEach(entry => {
                const id = entry.target.id;
                const tocItem = document.querySelector(`#toc a[href="#${id}"]`);
                if (tocItem) {
                    if (entry.isIntersecting) {
                        tocItem.classList.add("active");
                        prev_item.classList.remove("active");
                        prev_item = tocItem;
                    }
                }
            });
        }

        // タグ装飾
        let tag = document.querySelector(".tag-placeholder").innerHTML;
        document.querySelector(".tag-placeholder").innerHTML = "";
        tag = tag.replace("[", "").replace("]", "").split(", ").map(t => t.trim());

        tag.forEach(t => {
            const each_tag = document.createElement("span");
            each_tag.classList.add("tag");
            each_tag.innerHTML = "<a href='https://abap34.com/search?tag=" + t + "'> # " + t + "</a>";
            document.querySelector(".tag-placeholder").appendChild(each_tag);
        });
    </script>

</body>
</html>
