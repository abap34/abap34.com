[
  {
    "title": "GSoC 2025 Final Report ─ Development of a New Language Server for Julia",
    "post_date": "2025/08/26",
    "url": "https://abap34.com/posts/gsoc2025_final_report.html",
    "thumbnail_url": "https://abap34.com/posts/gsoc2025_final_report/image-3.png",
    "content": "GSoC 2025 Final Report\nThis blog is the final report of my work during Google Summer of Code 2025, where I worked on the project .\nThis was an exciting project to build a completely new language server that leverages Julia’s latest compiler infrastructure.\nAchievements\nSince this project was still in a very early stage, the proposal planned for me to take on a wide range of tasks in close collaboration with my mentor. In practice, I worked on a very broad set of features.\n\nThe image shows some of the PRs I opened for JETLS itself.\nAs can be seen from the number of comments, my mentor  and the Julia community members put in great effort to support my contributions.\nMajor Contributions\nHere are some of the major features contributed I made:\nImplementation of Go to Definition for methods\n<img src=\"gsoc2025_final_report/goto_method.gif\" alt=\"image-1\" width=\"600\"/>\nJETLS can also jump to functions defined by  macro :)In the future, we plan to extend this so that only the methods that could actually be called are suggested, based on type analysis.\nImplementation of Go to Definition for local bindings\n<video controls width=\"600\">   <source src=\"https://github.com/user-attachments/assets/cb924339-4475-4171-b390-db3c88ddc257\" type=\"video/mp4\">   Your browser does not support the video tag. </video>\n  This is where JuliaLowering played a remarkable role. It is great that such a feature can be implemented with relatively little code by leveraging JuliaLowering.\nImplementation of a basic configuration system\n<img src=\"https://github.com/user-attachments/assets/8128f891-cbfb-490d-a905-aa342c82d9fc\" alt=\"config_demo_v1\" width=\"600\"/>\nIt also allows dynamic changes after startup.In the future, We plan to  so that completion and validation can be provided in many editors.\nImplementation of recursive analysis (WIP, but close to completion at the time of writing so it may be merged when this is published)\n\nThe current analysis routines of JET did not have the ability to recursively locate and analyze the source code of packages. My contribution was to extend JET with such functionality and integrate it into JETLS.This required a detailed study of Julia’s package loading mechanism, which was quite challenging.\nSome UI improvements\nWhile analysis and various infrastructure are important, even small UI improvements can greatly affect the usability of a language server.  and  and are examples of such contributions. These are small implementations, but they improve the user experience highly.\n\nThe same kind of consideration was required when implementing the features described above. For instance, when implementing Go to ~, how should we decide what is \"under the cursor\" ? This is not a straightforward question. In cases like  and also in cases like , where should it go? ─ both to the definition of , isn’t it? ()\n\nAdditional details\nIncluding to these, many PRs—including bug fixes and contributions to related packages—were merged :)\n\n<details> <summary>merged PRs</summary>\n                                                      \n</details>\nAs noted earlier, this language server leverages Julia’s new compiler infrastructure. Deepening my understanding of these systems through this development was itself a great outcome for me.\nIt was also valuable that I was able to submit bug-fix patches for that infrastructure during the project.\n(ex: , ).\n\n\nMy understanding of both the Julia compiler and JET.jl has also grown significantly.\nIn particular, the many discussions I had with aviatesk about “virtual global execution” in this LS were crucial to its development.\nRemaining work\nAs described in the , JETLS already supports a variety of features. Beyond error detection, it also includes formatting and an excellent test runner. (⚠️ Clarification: This section describes overall LS progress, not just my own contributions.)\n\nHowever, there are still major challenges in performance and stability before it becomes practical. I am highly interested in addressing these, including applying known techniques for faster startup and researching cache strategies best suited to this LS.\nConclusion\nThis project has the potential to greatly impact the Julia ecosystem, and I am proud to be part of it.\n\nI would like to express my sincere gratitude to my mentor aviatesk and the Julia community for their warm guidance throughout GSoC. I also thank my university friends, lab seniors, and advisor for supporting me in various ways.\n\nI will continue to contribute to the success of this project.\n\n\n",
    "tags": [
      "Julia",
      "Language Server",
      "コンパイラ",
      "GSoC"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Google Summer of Code に Proposal が採択されました！",
    "post_date": "2025/05/09",
    "url": "https://abap34.com/posts/gsoc2025.html",
    "thumbnail_url": "https://abap34.com/posts/gsoc2025/image-1.png",
    "content": "\nあらすじ\nGoogle Summer of Code に Proposal が採択されました！\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">Google Summer of Code で Julia に出していた Proposal が採択されました！ 🎉🥳<br><br>Julia の最新のコンパイラインフラを利用して、強力な静的解析を備えた新しい Language Server の機能開発をガシガシやっていきます！✊ <a href=\"https://t.co/aEBHcSAnXa\">pic.twitter.com/aEBHcSAnXa</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1920609443131412630?ref_src=twsrc%5Etfw\">May 8, 2025</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nJulia の新しい Language Server の開発をやっていく予定です。\nプロジェクトページ: \n\nこの記事には具体的にやりたいことや準備の記録などを書いておきます。\n\n先行研究\n\nなどなど (GSoC 参加記 などで検索すればたくさん出てきます)\n\nGSoC とは\n他のブログに詳しい説明がたくさんあるので簡潔にまとめると、\n\nGoogle が主催するオープンソースプロジェクトへの参加を支援するプログラム学生は開発したいものの Proposal を書いて参加組織に送る参加組織は Proposal を審査して、採択の可否を決める 学生がオープンソースプロジェクトに参加して、開発を行うGoogle から報酬がもらえる (国とプロジェクト規模に応じて変わる. 日本で大規模プロジェクトだと今年は $.5400)採択率は 8% くらい? ただ、おそらく大量のインド人が応募しているために実態より競争率が高く見えていると思います。\n\nというやつです。\n開発したいもの、と書きましたが大抵の組織では Idea List が公開されていて、そこから選んで書くのが一般的です。\n参加まで\n昨年ごろから Julia の Language Server を作り直したいな〜 と漠然と考えていたのですが、 そのときたまたま Julia の Co-Founder である Jeff Bezanson さんとご飯を食べる機会がありました。\n\nそこで Language Server の話になり、同席していた  JET.jl の作者で Julia Hub の  さんにメンターを快諾していただいて、 最終的に aviatesk さんがかつて進めていた JET.jl を利用した Language Server の開発をやることになりました。\n\nその後応募が始まった頃に Language Server の開発を GSoC の Idea List に載せてもらい、 Proposal の執筆を開始しました。\n目次は以下のような感じです。\n\n\n内容は ⬇︎ で公開しています。\n\n<div class=\"responsive-card\">     <img src=\"https://lh7-us.googleusercontent.com/docs/AHkbwyJAJ9ogZ4D-SPHAvHHbJZ7-lFywdyQ9jcl6XQYA8tk6R5sqWwQ7lzkiUzLlq3QhwvimyeQ0Vy9OQiMhqjjr_bNP1BqUyFWNh7MASnt68E4Ui9Q9N3H7=w1200-h630-p\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://docs.google.com/document/d/1rk39WzYwvI1jEx9FtYwAynwVmjyjwjo_F9RExQBD3J8/edit?usp=sharing\"\">(public ver) proposal for GSoC 2025: JETLS  - Google Docs</a>     </div> </div>\n\n\n具体的にやりたいこと\nProposal に詳しく書いてありますが、せっかくなので日本語でいくらかまとめておこうと思います！\n(細かい話は Proposal を見てください)\nLanguageServer.jl の課題\n今、 Julia では  がメジャーですが、 LanguageServer.jl はいくらか課題を抱えていました。 \n主要なものを挙げるとしたら以下のような感じでしょうか。\nMissing References が頻発する\nLanguage Server の主要な機能として、 Go To Definition や Find References などがあります。\n\nこれは実装箇所や仕様箇所に飛べる便利な機能ですが、 LanguageServer.jl ではこれらがうまく働かないことが非常に多いです。\n(\"Missing\" で Issues を検索した結果: ) \n\nコードベースが複雑化してメンテナンスが難しくなっている\nLanguage Sever Protocol 自体が多くのことを要求するという事情もありますが、コードベースが複雑になってしまっていて、 全体を把握しているメンテナーの方がほとんどいなくなってしまいました。 \n(課題?) 型エラーなどの高度な解析が行われない\nこれは課題というよりかは設計思想とかの範疇だと思いますが、 LanguageServer.jl はそこまで高度な解析を行いません。\n例えば\n\nはもちろんエラー (実行時例外ですが！)　になります。 が、LanguageServer.jl は基本的に赤線は引いてくれません。\n\n🆕 Language Server\n新しい Language Server は以下のような特徴を持っています (もしくは持つ予定です)\n\nJET.jl を利用して、複雑な型エラーやパフォーマンスの問題を検出・警告するJulia の最新のコンパイラインフラを利用して、メンテナンス性と開発効率を向上させる\nJET.jl を利用して、複雑な型エラーやパフォーマンスの問題を検出・警告する\nJET.jl は aviatesk さんが開発している Julia の静的解析ツールで、型エラーやパフォーマンスの問題を検出することができます。\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/5e1cb9fc190b440ff9c856501aa24b482c4f11e2b1fc86a1fb3c5a2b6ea8f5e4/aviatesk/JET.jl\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/aviatesk/JET.jl\"\">GitHub - aviatesk/JET.jl: An experimental code analyzer for Julia. No need for additional type annotations.</a>     </div> </div>\n\n例えば \n\nはエラーになりますが、 ( は  型の配列で、  は定義されていないため) JET.jl はこれを検出してくれます。\n\nこのようなエラーを検出して Diagnostics として提供します。\n\n\n他にも型不安定性の表示や、そもそもの型推論結果の表示 (Types on Hover) などに取り組みたいと思っています。\nJulia の最新のコンパイラインフラを利用して、メンテナンス性と開発効率を向上させる\nJulia の パース・lowering  は FemtoLisp で書かれたものが長く稼働していたのですが、現在パーサは Julia自体で書かれたものが使われていて、 lowering も Julia で書かれたものの開発が進んでいます。\n\nJulia 製のものに変わることで、以前と比べると Julia コンパイラ以外のソフトウェアからも比較的利用しやすくなります。 これらを利用することで、 Lanuage Server 側で Julia コンパイラの最新の機能に追従するコストが下がることが期待されています。\n\nまた、これらの新しいツールチェインは位置情報をよく保存するようにできていて、 他の現代的なプログラミング言語のような「バイトレベル」のエラーを出せるようになると思います。\n\n他にもあるよ\n他にもいろいろな機能について議論していますが、長くなるので Proposal を見てください 🤲\nがんばります\n自分の周りでも最近は Rust を書いている人がずいぶんたくさんいるのですが、その理由の一つには rust-analyzer などの強力なエディタ支援があると思います。 Julia でも同じようなことができるように頑張っていきたいと思います。\n自分より遥かにできる方たちにメンターしてもらいながらチャレンジングなソフトウェアが書けるのは本当に楽しみです！ 楽しい夏にしていきたいと思います！\n(生活費をくださる Google 様に圧倒的感謝🙏🙏🙏)\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/LZ4PJky8agg?si=Ac94NmO-V6Bw6FaH\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n\n\n 実際には参加組織は Proposal への順位づけのみをして、 Google がその組織に割り当てた枠の数より小さければ採択ということらしい (?) ですがあまりよくわかっていません。 surface-AST を最適化などのために適した IR に変換する処理のことです",
    "tags": [
      "Julia",
      "コンパイラ",
      "GSoC",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "東京科学大学デジタル創作同好会 traP と共同でデータ分析コンペを開催しました！",
    "post_date": "2025/04/23",
    "url": "https://hack.nikkei.com/blog/trap_kaggle_competition_2025/",
    "thumbnail_url": "https://hack.nikkei.com/images/ogp/trap_kaggle_competition_2025.png",
    "content": "",
    "tags": [
      "機械学習",
      "データ分析コンペ",
      "kaggle"
    ],
    "featured": true,
    "external": true
  },
  {
    "title": "定数伝播の MOP 解の計算不能性の証明",
    "post_date": "2025/04/07",
    "url": "https://abap34.com/posts/mop_undeciable.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/leonberg/n02111129_4246.jpg",
    "content": "\nあらすじ\nデータフロー解析における MOP (Meet Over Path) 解の求解は、一般には計算不能であることを用いて示します。\nMPCP (Modified Post Correspondence Problem) に帰着させることで示します。 内容は Principles of Program Analysis に載っていたものにほぼ沿っています。\n前提: MPCP\n有名な決定不能問題の一つに PCP (Post Correspondence Problem) があります。\nPCP は次のような問題です。\n\nPost Correspondence Problem\n有限な文字列の組の集合:  が与えられたとき、 次を満たす有限の添え字の列  が存在するか?\n\n\nつまり、上下に文字列が書いてある「ドミノ」を (複数回の選択を許して) 並べたとき、上と下の文字列が一致するような並べ方があるか? を判定するという問題です。\n\nこの問題決定不能なのですが、少し変形した以下のような問題 MPCP (Modified Post Correspondence Problem) も決定不能であることが知られています。\n\n\nModified Post Correspondence Problem, MPCP\n有限な文字列の組の集合:  が与えられたとき、 次を満たす有限の添え字の列  が存在するか?\n\n\n\nPCP の最初のドミノが固定されたバージョンです。　\nが、これも決定不能であることが知られています。\n今回はこれを使います。\n証明\n次のことを示します。\n\n定数伝播の MOP 解の求解は計算不能である。\n\n\n以下のようなプログラムを考えます。\n,  を　 個のドミノの上下として、\n\nこのプログラムの最後の  の定数伝播の結果を考えましょう。\n に至る CFG 上のパスはドミノの並べ方に 1対1 で対応していることから、  解 における  の値は ,  が MPCP の解をもたないとき、またそのときに限り  になります。\n\n\nしたがって、  解が求まるとすると MPCP が解けてしまいます。\nよって  解の求解は計算不能です。\n感想\n任意の選択を任意回させる、みたいなのでポストの対応問題族に帰着させるのができるわけですね。\n決定不能であることを示すやつで毎回天才証明に唸ってしまうので、同じ作戦で何か証明してみたいところです。\n参考文献\n\n\n\n\n\n\n",
    "tags": [
      "静的解析",
      "コンパイラ",
      "データフロー解析",
      "抽象解釈",
      "計算可能性",
      "定数伝播"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "2024年度後期振り返り",
    "post_date": "2025/03/31",
    "url": "https://abap34.com/posts/hurikaeri_2024_1.html",
    "thumbnail_url": "https://abap34.com/posts/hurikaeri_2024_1/thumbnail.png",
    "content": "\n\n\n\n2024年度後期の振り返りです。\n今年の前期の振り返りは \n\n過去の振り返り記事は \n\n作った・作っているもの\nserver.abap34.com (ssh チャットサーバ)\nまずは一発ギャグです。\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/b02ffe6b941b3c6526c27959fd7211b6e02ab4bb44ae7d9ff696e1344b614c3f/abap34/server.abap34.com\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/abap34/server.abap34.com\"\">GitHub - abap34/server.abap34.com: just 🐩ᯓᡣ𐭩 ▶︎ </a>     </div> </div>\n\nこれは Go で書いた ssh サーバなのですが、 ssh すると ↓\n\n\n\n認証が始まり、\n\n\nチャットが始まります。爆笑。\n\nもちろんリアルタイムで更新されるので他の人と会話できます。\n周りに Discord で身内サーバを作っている人がいたのですが、エンジニアたるもの身内サーバくらい自分で書かんかいということで作りました。\n\n珍しく Go で書きましたが  日本語入力の削除がうまく行かないようで、 かなり嫌な気持ちになっているので他に乗り換えてちゃんとした TUI もついでに作りつつ乗り換えが濃厚です。 👆 fix するほどの気力はなく...\n\nmu (型推論付きの処理系)\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/56a834218c95be64b39ec1c9824387c9221e36ba05b39dec8d93a9a05de16f34/abap34/mu\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/abap34/mu\"\">GitHub - abap34/mu: Implementation of multiple dispatch and abstract interpretation based  static type analysis</a>     </div> </div>\n\n\nこれはそこそこ時間を使ったもので、 desciption にもあるように\n多重ディスパッチ抽象解釈ベースの型解析\nが載った処理系です。\n、 意外とちゃんとしています。\n例えば\n\n\nみたいなコードを書いて、\n\nちょっと最後ごちゃごちゃしてますが、この関数が \n に対して呼び出された場合は  または  を返す、が推論できます。\n\nこれは実装などブログにしました。 qiita に載せたのですが、同じものをこっちにも最近動かしました。\n\n<div class=\"responsive-card\">     <img src=\"https://abap34.com/posts/jci_06/image.png\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://abap34.com/posts/jci_06.html\"\">Julia Compiler Internals (06) - Implementing Small Julia Compiler</a>     </div> </div>\n\n全体作ることで細部まで色々と知れてよかったです。\n\nlapisla (定理証明支援系)\n\n多分これが一番時間を使った気がします。定理証明支援系  (とそのエディタ、そのレジストリ、そのほか色々全部のプラットフォームです。)\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/afc68be3c091e06c197c8ff8e8e7af61f5da0d76295b47b999c0267565cd7ce6/lapisla-prover/lapisla-prover\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/lapisla-prover/lapisla-prover\"\">GitHub - lapisla-prover/lapisla-prover: lapisla is a battery-pluggable theorem prover and ecosystem designed for everyone. Greetings! 👋</a>     </div> </div>\n\n\n<div class=\"responsive-card\">     <img src=\"https://trap.jp/content/images/2025/01/img_5128.png\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://trap.jp/post/2478/\"\"> \t\t\t冬ハッカソンで定理証明支援系 「lapisla-prover」(and more !) を開発しました！ | 東京科学大学デジタル創作同好会traP \t</a>     </div> </div>\n\n秋くらいに大学の授業で定理証明支援系を触ったときに色々と可能性と課題を感じ、それに一旦アプローチしてみました。\n最近は LLM-based の自動証明を色々調べていて、実際手を動かすフェーズになりつつあり、最終的には lapisla で賢い自動証明を提供したいですね。\n\n個人的には結構いい出来のソフトウェアだなぁと思っています。チームに感謝！\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">Lapispla で左単位元と右単位元が同じであることも言えた<a href=\"https://t.co/JShgd83G0F\">https://t.co/JShgd83G0F</a> <a href=\"https://t.co/3zvfTrQSK0\">https://t.co/3zvfTrQSK0</a></p>&mdash; ひゅ〜Men (@men_cotton) <a href=\"https://twitter.com/men_cotton/status/1889186482352767214?ref_src=twsrc%5Etfw\">February 11, 2025</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nすごいぜ\nコンペ開催\nまたコンペをやりました。\n\n<div class=\"responsive-card\">     <img src=\"https://trap.jp/content/images/2025/03/mosaic_20250315035433-1.png\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://trap.jp/post/2518/\"\"> \t\t\ttraP Kaggle 班 x 日本経済新聞社でデータ分析コンペを開催しました！ | 東京科学大学デジタル創作同好会traP \t</a>     </div> </div>\n\n\n今回は作問にかなり力を入れていて、 BigQuery を回しまくるくらいの規模のデータを触れて楽しかったです。\n詳しいことは上のブログを読んでください。\n\nabap34.com\nこのサイトも相変わらず色々新しくなりました。\n例えば  や 、　そして何よりブログの記事のデザインが大幅に見直されてちょっとマシな見た目になりました。\nまた  という構文でリンクカードが自動生成されるようになり、まさにこの記事のようなものが書きやすくなりました。 (ビルド時に ogp image などを取得して埋め込んでいます)\n\nデザインはちょっとダサいと思っているのでそのうち直します。\n\nあとしれっとダークモードと英語に対応しました。 (翻訳はすべてチャッピーに投げていて全然正確でないので、暇を見つけて直そうと思っています。)\nalmo (拡張 Markdown パーサ)\nこのブログを動かしているやつです。\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/3b5b763da5aef69c53298e49d5d08e982b2edcda4caa9ddf8a80d519d1e471a6/abap34/almo\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/abap34/almo\"\">GitHub - abap34/almo: [⚠️ WIP] ALMOは拡張Markdownパーサ・静的サイトジェネレータです。WebAssemblyを使ってブラウザ上で完結する実行環境を提供し、サーバを必要としないサンプルコードの実行環境やジャッジシステムを提供するページの構築を可能にします。</a>     </div> </div>\n\n本格的にビルドシステムの書き換え (ついでにユーザが触る部分は全部 Python に) をやろうとしているのですがシングルバイナリで配るために Hacky なビルドをしているせいで前途多難です。\n\n<div class=\"responsive-card\">     <img src=\"https://opengraph.githubassets.com/ed1f72e3735bfcdb2d52f009a40d84dcd1526b3e3c094b0ce9f5a28b70661597/abap34/almo/pull/167\">     <div style=\"margin: 0 10px 0 10px;\">          <a href=\"https://github.com/abap34/almo/pull/167\"\">ビルドシステムの書き換え by abap34 · Pull Request #167 · abap34/almo · GitHub</a>     </div> </div>\n\n前書いた　 くらいのことはするつもりでいますが、もう少しかかりそうです。\n進捗としては謎の Contributor が現れて  なぜ？\n\n??? (こうご期待！)\nこれは近いうちにまともな文章が出るのでここでは何も書かないんですが、 来年度前期はこれに集中することになりそうな面白いものに手を出しています、楽しみ！\n書いたもの\nJuliaCompilerInternals\n完全にブロガー化していますが、とくに  はこれの執筆駆動によって かなり Julia コンパイラについて詳しくなれたのでよかったです。\n\nとくにデータフロー解析のいろんな性質を頑張って導出した  とかなり実践的な  は書いてる過程でだいぶ思考が深まりました。\n\nその他ブログなど\nこれ結構面白くないですか？ こっちの解釈が広まってないのは個人的には変な話だと思っています。結構 Helix の操作に慣れてきました。上に書いたコンペでサークル完全引退おじいさんになったのですが、それより少し前にすでに Kaggle コミュニティの長は後輩に譲っており、そのときちょうど部内 + OB・OG の人の前で話す機会があったのでスライドにしました。数年後ノスタルジーを提供してくれそう\n\nその他・大学など\n卒業研究を除く必要単位を無事取り切りました ハッピー研究室配属があり、無事第一志望の研究室に配属されました！ﾔｯﾀｰプログラミング言語をやります。長いのでやりたいことは最後の 抱負 のとこに書いておきます観念してもろもろの所属を Science Tokyo に更新しました後期の Contribution 数は 1035 でした。 ()今年のセリーグ順位予想は 1-ヤ巨神横中広-6 でいきます。ところでセリーグに開幕三連敗しているチームがいるのですが...?\nふりかえりと抱負\nプ言語をやる研究室に配属されたわけですが、別に ml を辞める (?) わけではなく、いい感じに両方やっていきたい (大谷翔平) と思っています。\n\nここ数ヶ月は、どうするか割とちゃんと悩んでいて何人かの人に相談してみたりしていたのですが、やはり参入障壁というところを考えると ml <<< プ だろうから、大学では後者に取り組んだほうがいいのでは、 というアドバイスをいくらかもらったので、そういう選択をしました。\n\n実際 TL では大学で CS をやっていなくても ml バリバリやっている人を本当にたくさん見かける一方で、 CS専攻でなくプログラミング言語をやっている  (ここでいう「やる」は論文を書き、発表し ... を指しています)　人はあまり見かけないので、自分としてもまぁそうだろうなとは思っています。　\n\n最近は自動証明のようなところに結構興味を持っていますし、 (LLM が書いたコードに全部ちゃんと証明がついていたらめちゃくちゃ面白くないですか?)、\n\n一応へなちょこ データ分析・数値計算etc のプレーヤーでもあるので、そういうのを簡単に 安全・パフォーマンスよく実行できるために色々やっていきたいですね。 (例えば  に大衝撃を受けたのを今でも覚えてます！ こういう仕事ができたら楽しいだろうな〜 と思います)\n\n\nともかく、 相互に絶対役に立つと思っているので、どちらもちゃんと勝負できるレベルまで勉強できたらと思います！ とりあえず短期的にはプログラミング言語の勉強をがんばります.\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DeGkiItB9d8?si=tlb9DV7eFHif1w6K\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "日記",
      "振り返り"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "ROC-AUC の解釈",
    "post_date": "2025/03/01",
    "url": "https://abap34.com/posts/auc.html",
    "thumbnail_url": "https://abap34.com/posts/auc/image.png",
    "content": "\n\n二値分類の代表的な評価指標である ROC-AUC (Receiver Operating Characteristic - Area Under the Curve)  について説明します。\n結論だけ: ROC-AUC とは?\nROC-AUC は二値分類の評価指標で、 予測モデル  が 正例と負例からそれぞれ一様に選んだ  と  について  となる確率のことです。 \n\nつまり、ちゃんと正例の予測確率の順位を負例よりも高い位置に持ってこれているか？という「分離能力」を測る指標といえます。\n\n計算したいときは、scikit-learn の  を使うと便利です！\n\n\n定義と計算方法\n定義\nROC-AUC は正解ラベルの列  と予測確率の列  の組  に対して定まる量です。(ただし、 がすべて同じ値からなる場合は計算できません)\n\nROC-AUC を計算するには、まずは TPR (True Positive Rate,真陽性率) と FPR (False Positive Rate, 偽陽性率) を理解する必要があります。\nTPR と FPR は\n正解ラベルの列  と予測ラベルの列  に対して以下の用に定義されます。\n 1  TP  FP  0  FN  TN \nとして、\n\nです。日本語で書けば\n\n 真の正例のうち、正例と予測されたものの割合 (見落とさなかった率)\n 真の負例のうち、誤って正例と予測されたものの割合 (誤検知率)\n\n(多分こっちの方がわかりやすいですね)\n\nところでこれをするには予測も確率でなくラベルになっている必要があるわけですが、 閾値  を設定してそれぞれ振り分けることになります。\nしたがって 正解ラベルの列  と予測確率の列  に対して、  を  から  まで動かすことで、各  に対して TPR と FPR の値、 と  が定まります。\n\nこれをプロットして得られるののが ROC曲線です。\n\nこの ROC曲線と 直線 ,  で囲まれる面積が ROC-AUC です！\n上の曲線の「下」の面積ということですね。 (ROC 曲線を 0 から 1 まで積分した値, といってもいいです)\nROC 曲線を書く + 直感的な解釈 ①\n※ ここからは与太話です。\nここでは実際に ROC 曲線を書く方法を考えます。\n\n閾値は  から  まで動かすといっても  と  が変化するのは  が  の要素の値を超えるときだけですから、高々  個の閾値を考えれば十分です。\n\n実装するとしたらこんな感じでしょうか。\n\nなお, これは  のアルゴリズムの実装ですが簡単に  にできます。(別に  を明示的に計算しなくてもいいことを使うといいです)\n\n直感的な解釈を書きます。\n\n を  から  に変えたとき、一つの予測が  から  にかわったとします。\nこのとき、\n真の値が  だったとき (つまり、正解が不正解になったとき) は 1 減る は 1 増える は 減少 は 変化しない真の値が  だったとき (つまり、不正解が正解になったとき) は 1 減る は 1 増える は 変化しない は 減少\n\nとなります。\nしたがって,  から始まって閾値を動かしていき、\n\n不正解に変化   だけ  軸正の向きに進む正解に変化  だけ  軸正の向きに進む\n\nというのを繰り返していくわけです。\nここで、面積を大きくしたければ最初になるべく  軸負の向きに動かないのがいいです。 このことは 正例の予測確率の順位が上位である ことと対応しています。\n\nしたがって ROC-AUC は正例を上位に, 負例を下位に固められているか？を調べる指標と解釈できます。\n直感的な解釈 ②\nこのことをよりはっきり示す、最初に書いた事実:\n\nROC-AUC は 正例  と負例  を一様に選んだとき となる確率のこと。\n\nについて書いておきます。\n色々と進んだ結果もあるみたいなのですが \nここでは簡単に有限のサンプルに対してこれを示します。\n正例のサンプル数を , 負例のサンプル数を  として、  を正例の  番目のサンプル,  を負例の  番目のサンプルとします。\nここで、次の事実が成り立ちます:\n\nこのことは  軸負の向きに   だけ進み、そのときの「高さ」は   なることからわかります。\nここで、 の定義から\n\nです。\nなので結局\n\nとなります。これが示したいことでした。\n\n Mason, S. J., Graham, N. E. (2002). Areas beneath the relative operating characteristics (ROC) and relative operating levels (ROL) curves: Statistical significance and interpretation. Quarterly Journal of the Royal Meteorological Society (128): 2145–2166.",
    "tags": [
      "機械学習",
      "評価指標",
      "ROC-AUC"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "Julia Compiler Internals (06) - Implementing Small Julia Compiler",
    "post_date": "2025/02/16",
    "url": "https://abap34.com/posts/jci_06.html",
    "thumbnail_url": "https://abap34.com/posts/jci_06/image.png",
    "content": "\nあらすじ\n以前まで続けていた Julia コンパイラの内部構造についての記事について、一旦これまでの知見を使って簡略化した Julia のコンパイルプロセスを実装します。\nそのほかの Juia コンパイラに関連する記事は \n\n\n\nJulia と 型推論\nまず最初に、(みんなが思い浮かべるものという意味で) 一般的な型推論と少し違うのもあるので、Julia における型推論の利用のされ方について少し書きます。\n型推論 ?\nとくに意識して記述せずとも、特定の式が実行時にとりうる値の型についていくらかの非自明な事実が常に成り立っていることはよくあります。\n\n\nのように書けば、 の値は  です。 \nリテラルがなくとも、\n\nでは、 も  もつねに  になるでしょう。 \nさらに、\n\n\nという条件分岐を考えると、それぞれの条件分岐の中では　 は   (, ,  などの親) は  (,  などの親)\nという事実が常に成り立ちます。\n\n\nこの記事では Julia の Docs にならい、このような事実の導出─ 「あるコントロールフローにおいてある式が取りうる値の型情報を静的に導くこと」を 型推論 (Type Inference) と呼ぶことにします。\nJulia の処理系の特徴の一つは、この意味での型推論を行なうことです。 そしてさらに特徴的な点は、得た情報をもっぱらパフォーマンス向上のために使うことです。\nまずは型推論によってパフォーマンスを向上させることができる例を見てみます。\nパフォーマンス向上例: ディスパッチの静的な解決\n二つの整数を受け取って、その総和を計算する関数を考えます。\n\nこれを、ユーザ定義型  の組にも使えるようにしてみます。 この  は加算するとついでに 100倍されます。 \n\n\nJulia ではこれら各実装のことをメソッドと呼びます。\nつまり、 という generic function (総称関数) があって、\n を普通に足すもの を100倍されて足すもの\nという 2つのメソッドが存在することになります。\nこのとき、Julia の処理系は\n\nのような関数呼び出しを行う際に、すべての引数の実行時の値の型に基づいて  という実装を選択して実行してくれます。(多重ディスパッチといいます)\n複数のマッチする実装があるときは、そのうちもっとも「特化したもの」が選ばれます。 例えば\n\nという  があったときは  という呼び出しは下のメソッドが呼び出されます。  という型の組より  のほうが「特化している実装」だからです。\n\n多重ディスパッチを行うためには 引数 ,  の型が判明していないといけないわけですが、Julia の処理系は実装の選択を実行時に行うことでこれを常に可能にしています。\nしばしば混同される機能として、例えば C++ などにあるオーバーロードがありますが、オーバーロードは多重ディスパッチと異なり静的に実装を選択します。\nまた Python や Java の標準的な Class のように引数のうち一つを特別視して実装を選択 (シングルディスパッチ) せずに、全ての引数から実装を選択するのも多重ディスパッチの特徴です。\n\nさて、多重ディスパッチによる実装の選択は、ものすごくざっくり書けば、\n\nのようなことをしているわけです。\n\nしかし、これを実行時に行うと 毎回  を呼び出し、メソッドテーブルに検索をかけるコストがかかります。\nところがどっこい、型推論によって例えば 「引数は全て つねに  である」ことなどが導ける場合、この型チェックと検索をスキップして、直接特定のメソッド呼び出し (この場合は ) にすることができます！\nこれは型推論によってパフォーマンスを改善できる代表的な例です。\n実際に Julia コンパイラがそのような最適化を行なっていることを確認してみましょう。\n下のような二つの関数 ,  を考えます。\n\nどちらも  の総和を計算する関数ですが、 の出どころが  : ただのグローバル変数  :  宣言したグローバル変数\nという違いがあります。実は、このことは型推論をする上で大きな差を生みます。\nというのも、 宣言されていないグローバル変数は常に任意の型の値に書き換えれられる可能性があるので、Julia コンパイラはその型を  と推論するからです。\n確認してみましょう。\nJulia にはコンパイラが何を考えているのかを調べる手段がたくさん備わっており、例えば  マクロを使うと型推論の結果やそれに基づく最適化を施した結果を見ることができます。\n\nまず  は以下のようになります。\n\n計算過程の式は全て  と推論されていて、返り値も  となっています。 さらに、 という generic function の呼び出しがそのまま残っていますね。\n一方  は (長いので出力をかなり省略しています。ぜひ手元で試してみてください)\n\n返り値は  と推論されていること、そして  の呼び出しは消えて具体的な実装に置き換えられていることがわかります。さらによく見ると、 のような  向けの特化した関数が使われているのがわかると思います。\n\n実行速度を調べると\n\nと、 の方が 2 倍近く高速です！\nこうして Julia 言語は型推論に基づく最適化で良好なパフォーマンスを得ていることがわかりました。\nこのような例を出すと「Julia ではパフォーマンスを出すにはコンパイラの気持ちを理解しなければいけないのか」となるかも知れませんが、Julia コンパイラは大変賢く、パフォーマンスのために気をつける必要があることは (少なくとも同じような「簡潔だけど高速」という売り込みの言語に比べれば) かなり少ないというのが私の印象です。\nそのほかの特徴\nJulia の型推論プロセスが持つ特徴としては、以下のようなものがあります。\n1 推論は できる限り 行われる\nJulia の処理系は推論精度 (による実行時間の短縮) とコンパイル時間とのトレードオフに気を使って実装されています。\nインタラクティブに行いたい科学技術計算ではコンパイル時間がいたずらに長くなるような処理系の体験はとても悪くなるからです。\n理論的に達成できる限界まで精度よく推論できなくても実行自体はできるので、実は導出可能であってもコンパイル時間の短縮のため推論を行わないこともあります。\n\n2 推論のエントリポイントは関数呼び出し\nJulia の関数はあたらしい引数の型の組で呼び出されたまさにそのときにコンパイルされ、実行されます。 そのため、Julia の型推論プロセスは、渡された具体的な値の型から出発します。\n3 推論は inter-procedural に行われる\n\nJulia の型推論は関数境界を跨いで行われます。つまり、ビルトイン関数とは限らない (= 返り値の型が明らかでない)  の呼び出しを含む  をコンパイルする際、 に対する推論も行われます。\nまとめると、以下のようになります。\nJulia の型推論プロセスのまとめ\n\nJulia の型推論プロセスは\n関数の実際の実行を始めようとする まさにそのときにその引数の 値の型 からある箇所での変数の型の情報を 関数境界を跨いで 再帰的にできる限り推論する こと(でパフォーマンスを向上させる)\nプロセス。\nまた、得られる型情報の利用のされ方も一般的な静的型付け言語とはかなり異なります。\nJulia は JIT コンパイル で動作する動的型付けの言語です。コンパイル時に型検査は行われず、例えばメソッドが存在しないことがコンパイル時にわかってもコンパイルエラーなどとはせず、実行時例外になります。\n\n\n\nその意味で、こと Julia コンパイラ本体においては型推論はほとんどパフォーマンスのためのいち情報に過ぎないわけですが、本体にないだけで Julia の型推論を使って静的にエラーチェックをしたり、rutime-dispatch などを検知するパッケージなどもあります。\nここでは JET.jl を紹介します。\nhttps://github.com/aviatesk/JET.jl\n\nJET.jl は、Julia コンパイラの型推論プロセスを利用して、上のように  の呼び出しで  に対する  の実装があるかを静的に検査してくれます。\nまた、このようなツールの組み込みはまだ発展途上ですというのが正直な答えになってしまうものの、Language Server も一応あります。\nhttps://github.com/julia-vscode/LanguageServer.jl\n\nJulia の型システムそのものについての詳しい解説は (30 記事くらいになってしまうので) ここでは深くは触れません。\n か、あるいは日本語の書籍もいくつかあってその中である程度解説されているのでそちらを参照してみてください。 型システム関連だととくに実践 Julia入門は相当詳しく書かれています。\n\nJulia の型推論までのプロセス\nさて、ここからはこの型推論プロセスを作っていきます。\nまずは実装を始める前に、型推論プロセスの入出力を明確にしておきましょう。\n\nまず、Julia の処理系はソースコードをパースして (surface-) AST を作ります。\nしかし、AST はそのままだと最適化が実装しにくいので、Julia の型推論は AST を最適化しやすいよう変形した IR に対して行われます。(この処理は lowering と呼ばれます)\n実際にはさまざまなコンパイラへのヒントなども含みますが、使われる IR はざっくり言ってしまえば\nマクロが全て展開されて全ての糖衣構文 (for, 三項演算子など) が解体されてGOTO を使った直列の命令列への書き直し (linearize) が行われた\n形式です。\n によって実際に AST から IR に変換した結果を見ることができるのですが、\n\nなんだかごちゃごちゃしているように見えるかもしれませんが、for 文が解体されて条件付き goto を使った直列の命令列への書き換えがされていることがわかります。\n\nこのような IR も Julia 自体での表現 ( 型) を持つので、触って遊ぶことができます。\n\n一方で lowering の処理それ自体は現在は C や Scheme で実装されているのですが、最近は Julia によって書き直すプロジェクトが進んでおり、いずれは Julia で完結するかもしれません。(パーサもかつては Scheme 製でしたが今は Julia製のものが動いています。https://github.com/JuliaLang/JuliaSyntax.jl)\nhttps://github.com/c42f/JuliaLowering.jl\nこの lowerd IR を受け取り、型情報を付加したものを出力するのが目標です。\n\n\n\nJulia の型推論アルゴリズム　─ 抽象解釈\nJulia の型推論は、抽象解釈という枠組みのもと構築されています。\n最初にも書きましたが、これを正確に説明することにすると大変なボリュームになってしまうので、詳しい話は  に譲り、ここではかなり簡単な内容に留めます。\n抽象解釈は、簡単に言えば\nプログラムの具体的な値を少し抽象化して「評価」する枠組み\n\nのことです。例えば \n現れるのはすべて自然数演算は掛け算だけ\nという言語で、\n\nというプログラムがあったとします。 このとき、ある変数がある命令の実行直前,直後に 偶数であるか？ 奇数であるか？というのを解析することを考えてみます。\n抽象解釈は、元のプログラムの変数を例えば 「偶数か奇数」「偶数」「奇数」「未定義」というような抽象状態に割り当てることによって行います。\nつまり上のプログラムを\n\nというように評価するわけです。 (ここで、「実行」という言葉を使わなかったのは、もとのプログラムと同じ順序で制御フローを辿って評価するとは限らないからです)\nそして、この評価は\nリテラルの代入は (元のプログラムの) 右辺の値の偶奇が入る掛け算の代入は (奇数)  (奇数) は奇数, (奇数)  (偶数) は偶数, ...\nという抽象化したもとでの意味関数を定めることによってできます。\n\nさらに、抽象状態の間には取りうる値の包含関係、つまり「具体度」「情報量」と捉えられる順序が定められます。\n今回は 「未定義」  「偶数」  「奇数」 「偶数または奇数」 という感じでしょうか。\n\n\n\n\n\n\nこのもとで、なるべく具体的なものを求めましょう. という形に定式化することで、できる範囲で正確な静的解析を行うようなアルゴリズムを考えることができます。\n\nさて、この 偶数 or 奇数? というのを型っぽいものに置き換えれば型の静的な解析ができそうなのは何となく理解できるかと思います。\nなので問題は\nこのような抽象的な評価はどのくらいまでなら詳しくできるのか ?型レベルに抽象化した評価、というものは出来るものに含まれるのか ？\nになります。\n(例えば具体的な値と完全に対応させればそれはただの具体的な実行ですが、これは当然停止しないこともあります)\n\nそこでこのくらいなら解けますよ. というのが考えられています。\n先ほども書いたようにここでその話を展開すると同人誌になってしまうので、気になる方は上のリンクを踏んでもらえればと思います。\nここでは今回利用する結果だけを簡単に述べます。\n抽象解釈の枠組みで、「ある命令の実行前後でプログラムの抽象状態のうちなるべく具体的なものを求める」という問題である「データフロー解析問題」を解くことができます。\nデータフロー解析問題に対しては、抽象状態とその順序, そして意味関数が\n意味関数が単調抽象状態と順序関係が無限上昇鎖を持たない束をなす\nという条件を満たすときに停止する求解アルゴリズムが知られています。\n一つ目の条件は、順序が具体度を表すことにすると\n「より具体的な状況で関数を実行した結果は、より具体的になる」\nと表現できるわけで、これは自然な条件です。\n二つ目の条件についてここで説明するのはやや大変です。投げやりで申し訳ないですが、やはり先ほどのリンクを見てください。\n\n今回もこれを使って型推論を行います。\n作るもの 〜 理論編 〜\nでは、実際に Julia の処理系を模倣した簡易的な処理系を作っていきます。 (mu という名前をつけました。)\n実装はすべて\nhttps://github.com/abap34/mu\nに置いておきます。(良かったら star つけてください)\n\n今回作る言語は多重ディスパッチをサポートします。つまり、\n\nのような結果を得ることができます。\nさらに、このディスパッチを静的に解決ができる場合は解決することにします。 つまり、 という呼び出しにおいて ,  は  だ、などという事実が導けた場合にはディスパッチを実行時にはノーコストで行えるようにします。 (つまりチェックがノーコストでスキップされます)\n型\n簡単のために、ユーザ定義型は作れないことにして、この言語に現れる型は以下で固定されているとします。\n  \nまずは一部の見慣れない型の説明を含めて、この言語がとる型システムについて少し書きます。\nまた、このシステムは Julia の型システムを模倣したものになっています。\n型の階層構造\nこの言語の型の集合は以下のような親子関係で半順序集合をなします。\n型  が  の 親であることを  とかくことにして、\n親子関係  である値の集合が  である値の集合の部分集合であるとき、またそのときに限り \nこの考え方にそって、今回登場する型に以下のようなグラフで表されされるような親子関係を定めます。\nこのグラフに現れる型の組については、 とが同じか、このグラフの  から  への経路であって、 が  よりも先に出てくるものがあるとき、またそのときに限り  は  の親です。\n\n\n例えば , ,  です。\n\n具象型と抽象型\nここで、上のグラフで、頂点がオレンジと水色で塗り分けられていましたが、\nこれは、今回の言語の型システムにおける 具象型 (Concreate Type) と 抽象型 (Abstract Type) を表しています。\n具象型はインスタンスが作れる型のことです。\nつまり、 の値の型を取得する関数  のような関数があったとき、これの返り値は必ず具象型になります。抽象型である ,  などが返ることは決してありません。\n今回の場合 , , ,  などが具象型にあたります。\n抽象型は具象型をまとめて構造化して、多重ディスパッチの制御をしやすくすることがその役割です。\n 型\n 型の説明をしましょう。\nこれは、全ての要素の型が全て  の子である  次元配列です。\n\n は型パラメータと呼ばれるもので、例えば  として文字列からなる 1次元配列を、  で実数 (今回は  または ) からなる 2次元配列などを表現できます。\n型パラメータを導入したときに考える必要があるのが次のような問いです。\n は  の親か？\n今回の型システムは、 について以下のような規則を採用することにします。\n不変性 (Invariance)\n は     なる 任意のパラメータ ,  について  と  は親子関係でない。\nつまり、 は  の親ではないことにします。\nこのような性質─\n型パラメータ  を持つ型  が 任意の相異なる型パラメータ,  に対して (たとえ  であっても)   でない\n\nのことを 不変性 (Invariance) といいます。\n不変性を採用することが仕様として絶対の正解かというと全然そんなことはなく、 そもそも Julia の型システムにおいても例外が存在しますし(後述します)、色々な言語でいろいろなシステムが採用されています。逆に  ならば  という性質を 共変性 (Covariance) といいます。\nこれらの説明も長くなってしまうので気になるかたはこれらのワードで検索してください。\nとにかく、こっちを採用したことによって先ほどの親子関係がなす階層構造はこんな感じになります。\n\n型パラメータとして  が追加されたことで、型の数が有限でなくなりました。\n\n 型\n 型は簡単にいうと任意の値を表す抽象型です。 取りうる値がこの言語に存在するすべての値であることを表します。\n今回はこれが親子関係における最大元、つまり任意の型  に対して  な型になります。\n 型\nとなると、逆に取りうる値が存在しないことを表す型が最小元となります。\n今回はこれを  という名前にすることにします。\nつまり 任意の型  に対して  です。\n 型\nTuple は値の組を表す型で、型パラメータとして型の組を取ります。\n例えば  は 　の値です。\nここで注意点として、 型は共変性を持つことにします。 例えば  です。\nというのも、型 がシグネチャを表現するために用いられるからです。\n多重ディスパッチの説明で書いたように、メソッドを選択する際には引数の型のうちどれがもっとも特化されているかを調べる必要があります。この比較を成り立たせるには共変性を持たせるのが自然です。\n 型も型パラメータとして任意個の型を取りますから、これを導入するとやはり型の集合が無限個になってしまいます。\n\n 型\n 型は、型パラメータとして非空の  型の集合を取ります。\nこれは名前の通り和集合の表現に近く、 , ,  です。\n\n 型を含む親子関係は Julia の仕様に沿って以下のように定めます。\n\n\n 型  (型パラメータ ) と 型の親子関係\n の全ての要素が  の子であるとき、またそのときに限り  ある  の要素が存在して  の親であるとき、またそのときに限り \n\n<details> <summary> Tuple型も含む親子関係 </summary>\n\n\n 型の親子関係は  も絡むとよりややこしくなります。\nというのも、同じ集合を表す複数の表現が存在するからです。例えば  は  と等価です。\n簡単な実装の仕方としては、適当な標準形に変換してしまって比較するという方法があります。 例えば  はトップレベルにのみ存在するように変換するのは容易です。\nこの方法は実装は容易ですが型パラメータのネストの深さに対して指数時間かかります。 なので Julia の処理系ではより高速な方法が用いられています。\n\nこのように親子関係の判定は実は少しややこしく、進んだ面白い結果として、少し前までは Julia の親子関係の判定は決定不能であったというものがあります。\n\n\n\n\n\n\n\n</details>\n\n\n\n\n\nさて、こと型推論のことを考えると、if文の分岐でそれぞれ ,  が返るようなケースでは  のように表現できそうですから、これを導入することによって強い表現力が得られそうな感じがします。\n\n\n\n\nしかし、強いものの計算が大変なのは世の常です。\n 型は強力ですが型システムの取り扱いをとてもややこしくします。\nここからはそのことを見ていきます。\n束としての性質　─ 有限性条件の反例\n今回考える　(型の集合, 親子関係)  は実は束になっています。\n\nでは型推論はデータフロー解析問題に落としこめばスッと解けるでしょうか？\n実はこのままだとうまくいきません。 データフロー解析問題の反復解法はその停止性のために\n意味関数の単調性抽象状態の束の高さの有限性\n\nを要求していました。しかし、今回は以下のような無限長の上昇鎖が構成できてしまいます。\n\n型集合が無限にあること、 型が存在することによってこのような問題が発生してしまったわけです。\nなので、単純に前回のアルゴリズムを適用するだけでは収束性が保証されません。\nプログラムの具体的な実行が停止する保証は当然しなくていいわけですが、 コンパイルプロセスは、それがたとえ不正なプログラムであったとしても必ず停止させなければいけません。\nそこで Widening と呼ばれる抽象解釈で一般的なテクニックを使うことでその停止性を復活 (?) させます。\n一旦、いろいろ忘れて Widening についてみていくことにします。\nWidening\nWidening は、(今の状態, 更新したい状態) から次の状態を出力する  に望ましい性質を持たせることで無限長の鎖を有限回で登り切れるようにスキップするテクニックです。\nまずは定義と例を紹介します。\nWidening Operator\n が半順序集合であるとする。\n が次のような性質を満たすとき、   が (pair-) Widening Operator である という. \n\n性質1 (被覆性)\n任意の  で  かつ  \n性質2 (停止性)\n鎖  に対して、\n と定める。このとき  は次の性質を満たす。\n[性質] ある  が存在して  \n\n具体例\n を、すべての整数区間の集合と最小元のための特別な要素を加えた集合、つまり\n\nとして、区間の包含関係で  を定義します。 (ここで  は任意の区間  について  なるとします)\nそして、次のように  を定めます.\n\nこのとき  は Widening Operator です。\n被覆性は明らかに成り立ちます。\n停止性も左端・右端だけが拡大するケースと両方が拡大するケースをそれぞれ考えると、したがうのが簡単にわかります。\n\n\n\nWidening の役割\n更新時に Widening Operator を挟むことで無限に状態が更新されることがなくなるので ( 停止性)、一般の束に対して収束するデータフロー方程式の反復解法が作れます。\nさらに、Widening には\n近似精度の調節役収束を早めるヒューリスティック\nの役割を持たせることができます。\n上の例ではすぐに諦めて区間を最大まで拡大したわけですが、例えば\n幅  まではそのまま持つ.幅  を超えたら   にする\nように  を定義すれば、 を調節することで望ましい程度に近似精度を調節することができます。\n他にも、たとえ高さが有限であっても非常に高い束は解析が実用的でないことがあります。 (求解アルゴリズムの最悪計算量は束の高さに比例します)\nそのようなときに適切に「スキップ」してくれる Widening Operator を導入することで、高速に収束させることができます。\n\nさて、今回実装する型推論においても、Widening によって型推論の収束性を保証します。 どのような Widening を用いるかは実装のセクションで検討することにしましょう。\nWidening を導入したデータフロー方程式の反復解法\n前回の記事に載せたプログラムを再掲します。\n(実は自明な効率化があり、それをすることで実際 Julia で使われているアルゴリズムと一致するのですが、それを書く時間がないのでここでは引き続きこれを使います。気になる方は  をみてください)\n\n\n導入は簡単で、 の更新をするときに Widening Operator  を挟めば良いです。停止性と元のアルゴリズムの証明と照らし合わせれば、このアルゴリズムの停止性がわかります。\n\n\n\nWidening の被覆性は、順序関係  でいうとより大きい方に結果を持っていくことを要求しています。\n抽象解釈の枠組みにおいては、これはより情報量が少ない側に情報をまとめることに相当します。これによって Widening を導入してもその見積もりが危険になる (導けないはずの事実が導かれる) ことはありません。\nまとめると、Widening は以下のようなものです。\n\n\nWidening\nWidening は\n解析の安全のための 被覆性解析の停止のための停止性\nを満たした Widening Operator  を状態更新の際に適用することで、状態更新を安全な側へ「スキップ」して有限時間でデータフロー解析問題を近似的に解くためのテクニック。\n\n実装\nそれでは実際にこの世の全てを実装していこうと思います。\nパース \nこれに関してはあまり今回の記事で本質パートでないので、少し軽めに説明します。\n今回は PEG を使って構文を定義しました。お好きな方法でパーサを定義してもらえればと思います。 面倒であれば S式や json を入力にしてしまうという手もあります。\nパーサのディレクトリ: https://github.com/abap34/mu/tree/main/src/parse\nAST は Julia の構造を参考に、ノード自体の情報と子ノードを Vector で持つ形式にします。\n\n\n例えば\n\nというコードをパースすると、\n\nという AST が構築されます。S式っぽい見やすい printing を頑張って書くと  \n\nという感じです。\nlowering\nIR の表現\nさて、lowering です。\nこれは  を受け取って直列の命令列に変換するわけですが、今回の処理系では関数単位でこのような処理が行われます。\n にそれら命令列の定義があります。\nまず、命令は\n\nと定義されて、IR はこれの列 (にいくらかの情報を持たせたもの)  として定義します。\n\nこの上で、関数全体の lowering された後の表現を保持する  を定義します。\n関数名, 引数 (型アノテーションの情報も含みます), そして中身の IR を保持します。\n\nlowering の実装\nそれでは、上に示した表現への変換を実装します。\nとはいえ、行うことは本当に場合わけを頑張ることのみです。\n例えば、while 文の lowering の処理を見てみましょう。(https://github.com/abap34/mu/blob/33cedc918a83b4fd6ce8b8bc43f1e50236c5075a/src/lowering/lowering.jl#L157)\n\n\nコメントにもあるように、\n\nは\n\nと変換することができます。なので、ラベルの id を生成して、上と一致するように順番に命令を追加していけば良いです。\n注意が必要なものとしては、関数呼び出しの中で関数呼び出しが含まれるケースがあります。\n\nを考えてみます。これは、\n\nという AST にパースされますが、中間変数  を導入して\n\nと lowering することにします。右辺が単一の関数呼び出ししかしないことにすると後の実装がしやすくなるからです。\nなので、関数呼び出しに対しては\n引数をチェック→ もし式なら新たに変数名 (e.g. ) を生成して、その式を lowering してその結果を生成した変数名に代入→ 定数, 変数ならそのまま\nというのを再帰的に行うことで右辺を単一の変数呼び出しにします。\n\n先ほどの関数の lowering 結果は以下のようになります。\n\nいい感じになってきましたね。ここまできたら簡易的なインタプリタを書いて実行することも簡単です。\n今回の処理系でも Verify のために具体的な実行を担う  が実装されています。\nhttps://github.com/abap34/mu/blob/main/src/interpreter/concreateinterpreter.jl\n型推論の実装\n型遷移関数の実装\nそれでは、型推論を実装します。\nそのためには抽象状態 (今回は上で出てきた型たち) とその順序 (今回は親子関係)、そして lowering された後の各命令について、抽象状態がどのように変化するかを表す意味関数を定義する必要があります。\n上の型の集合を ,  命令全体の集合を , 変数の集合を  とします。\n抽象状態は、各変数の型ですから  から への関数です。\nそして、抽象状態上の順序関係を以下のように定めます。\n \nここで  は上で定義した親子関係です。\nそして意味関数  を以下のように定めます。\n(実装は  です)\n1.  が  以外のとき\n抽象状態は変化しません.\n2.  が  のとき\nこのとき抽象状態が変化します。\n が  への代入だったとして、  を考えることにしましょう。\n  が  のとき、右辺は\n 1. リテラルまたは変数のとき  2. builtin の呼び出し  3. generic function の呼び出し\n\nの 3つで尽くされます。\n1 のとき\n単に右辺の値の型を調べてその変数の抽象状態を更新すればいいです。\nつまり、抽象状態  のときに定数  の代入によって新たに得られる抽象状態  は\n\nになります。(右辺が変数  の場合は上の式で  です.\n実装は   にあります。\n\n2 のとき\nこれも簡単で、builtin 関数は少ないのでその型遷移は書き下すことができます。 今回は  に実装があります。\n\nJulia言語も  があり、Compiler/src/tfuncs.jl　にその型遷移が記述されています。例えば比較演算子は  を返す、などは  実装されています。\n\nこのハードコードされた型遷移関数を  と書くことにすると、 は今回の設定ではビルトイン関数の名前と引数の型を受け取って帰り値の型  を返すような関数です。\nつまり   では\n\nとなります。\n3のとき\nさて、問題は 3. の generic function の呼び出しです。\n例えば推論のある段階で  が  または  であることが判明しているとして、generic function  が  に対する実装も  に対する実装も持っている場合があります。\nこのとき  はどちらのメソッドの呼び出しにもなりえますから、その返り値の集合から、安全であって最も具体的なもの、つまり最小上界を取れば良いです。\n\n関数呼び出しの型遷移\ngeneric function  を引数  で呼び出したときの型遷移関数  は、メソッドの型遷移を ,  呼び出しうるシグネチャと実装の組  の集合を  として\n\n\n\n\nここで、 の計算こそが求解アルゴリズムの仕事です。この中でも  は使いますが、generic function  の呼び出しは最終的には builtin の呼び出しに到達しますから必ず計算可能です！\nと言いたいところなのですが今回は実装の煩雑さ回避のために誤魔化しをしていて、うまくいかないケースがあります。末尾の 「この記事で誤魔化しているところ」を参照してください。\n\n実装は  にあります。\n が右辺の計算です。\n\nwidening の実装\n続いて widening を実装します。今回は次のような widening を実装することにします。\n 型の型パラメータが 10個を超えるまでは更新を続ける.10個を超えたら、型パラメータのうち共通の親であって最小の abstract type にする\n今回は無限上昇鎖の構成は 型を使ったもののみであること、abstract type が有限であることからこれは Widening Operator です。\nこれを組み込んだ求解アルゴリズムを実装することで、型推論は常に停止します！\n実装は   にあります。\n実行\nここまでを実装すれば、(多少インターフェースを整える必要はありますが、) 型推論が動くようになります！\n試してみましょう。\n次のようなとても単純な例で見てみます。\n\nこの関数の返り値の型を推論してみると...\n\n🥳🥳🎉 見事！ 返り値は  または  または  と推論できています 🎉🥳🥳\nさらに、色々試せるよう、mu は mu自身で書かれた (とても貧弱で偏った) 標準ライブラリを備えています: \nこれを使って、widening の効果を実感してみましょう。\n標準ライブラリを使うと以下のようなコードが書けます。\n\n は、配列の次元を増やすような操作です。 (もちろんこれはビルトインではなく、標準ライブラリの  や  などによって書かれた標準ライブラリの関数です。)\nこの  の返り値の型を推論してみます。\n\nこのように  と推論できています！\n\nこれは widening による効果で、while 文の中で  と更新され、これが 10回繰り返された時点で widening によって共通の親である  になり、推論が収束しているわけです！\n\nちなみに、どのような推論ができるかは  を見ると色々あるので眺めてみても面白いかもしれません。\nディスパッチの静的解決\nここまで来ればこっちのもので、型推論によって各命令の実行直前の変数の型がいくらかわかりますから、マッチするメソッドが一つに限られるかを調べて、それによって置き換えれば良いです。\n(すみません、これはタイトル詐欺で、この置換はまだ未実装です。ここまで来たら LLVM を使ってバイナリを吐けるようになる方が絶対面白いと思うので今後この部分は書きます。)\nこうして高速な実行が可能になります。\nこの記事で誤魔化しているところ\nJulia の処理系と比較すると当然大量の簡略化が入っているわけですが、主要な点を挙げると以下のようなものがあります.\n\n型システムの簡略化　─ ユーザ定義型をサポートしていませんしJulia の型システムはもう少し表現力豊かです。相互再帰のサポート ─ 実は今回のアルゴリズムだけでは相互再帰で無限ループになるケースがあります。Julia 本体では相互再帰を含む関数呼び出しでも停止します。ビルトイン関数がちょっとリッチ ─ Julia のビルトイン関数はもう少し洗練されており、特に配列操作周りは今回は誤魔化してやや高レベルな操作が入っています。コンパイル時間の考慮がない ─ 全てを推論しています。\n\n感想\nやはり自分で実装することによって色々と明確になってよかったです。 次は SSA IR の最適化パートを読んでみようかと思います。\n\n参考にした文献\nBezanson, Jeffrey Werner. Abstraction in technical computing. Diss. Massachusetts Institute of Technology, 2015.Cortesi, Agostino. \"Widening operators for abstract interpretation.\" 2008 Sixth IEEE International Conference on Software Engineering and Formal Methods. IEEE, 2008.https://github.com/aviatesk/grad-thesishttps://github.com/JuliaLang/julia\n\n https://x.com/Ag_smith/status/1871469153233826192 Julia は関数が初見の型の組の引数で呼び出されたまさにそのときにコンパイルされるという意味で JIT コンパイル方式の言語と位置付けられていますが、 例えば V8 がするようなTracing による最適化は行いません。なので Julia は単にコンパイルのタイミングが遅かったりバイナリを明示的に名前がついたファイルとして出力しないだけで、実装の実態は AoT コンパイルに近いです。 (全ての要素が  なわけではありません。例えば  は  です.) Julia においては  のパラメータは空とすることができます: . Julia においてはこの型は  のエイリアスで、この記事でいうところの  型にあたります。 Zappa Nardelli, Francesco, et al. \"Julia subtyping: a rational reconstruction.\" Proceedings of the ACM on Programming Languages 2.OOPSLA (2018): 1-27. Belyakova, Julia, et al. \"Decidable Subtyping of Existential Types for Julia.\" Proceedings of the ACM on Programming Languages 8.PLDI (2024): 1091-1114. Belyakova, Julia, et al. \"Decidable Subtyping of Existential Types for Julia.\" Proceedings of the ACM on Programming Languages 8.PLDI (2024): 1091-1114. Chung, Benjamin, Francesco Zappa Nardelli, and Jan Vitek. \"Julia's efficient algorithm for subtyping unions and covariant tuples (Pearl).\" ECOOP 2019-33rd European Conference of Object-Oriented Programming. 2019. より一般に集合に対する演算として Widening Operator を定義する方法もあります。これは set-Widening Operator などと呼ばれます. 詳しくは  Cortesi, 2008 などをみてください (参考文献にあります)",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "コンパイラ",
      "束論",
      "アルゴリズム",
      "抽象解釈",
      "データフロー解析"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "定理証明支援系 「lapisla-prover」 を開発しました！",
    "post_date": "2025/02/09",
    "url": "https://trap.jp/post/2478/",
    "thumbnail_url": "https://trap.jp/content/images/2025/01/img_5128.png",
    "content": "",
    "tags": [
      "定理証明支援系",
      "プログラミング言語処理系",
      "形式検証",
      "コンパイラ"
    ],
    "featured": true,
    "external": true
  },
  {
    "title": "開発環境を紹介しますアドベントカレンダー @abap34",
    "post_date": "2024/12/06",
    "url": "https://abap34.com/posts/devenv_advent.html",
    "thumbnail_url": "https://abap34.com/posts/devenv_advent/image-1.png",
    "content": "\n\nこの記事は、 6日目の記事です。\nこんばんは\nおい全然埋まってないぞ！！！！  \nみなさんはあんまり使っている人がいない変な CLI ツール, エディタ, Chrome 拡張などをお使いでしょうか？\n\nそうでなくともこの手の便利ツールを網羅的に知ることは難しいので、実は人の開発環境を見るのは結構面白いものを知れます。\n\nというわけでこういうアドカレを作ったのですが全然埋まっていないのでまずは自分で書こうと思います。\n\n(ここでいう開発環境は本当に広い意味で、開発に使うものの話ならなんでも良いです)\n網羅的に書くのは当然無理なので適当に変なやつを載せます。\nBasics\n\nOS: macOS\n小学校1年生のときに Mac を与えられて以来、 14年間　macOS を使い続けています。\nもはや他の OS を普段使いすることは考えられないです。\n\nターミナルエミュレータ\n使っているターミナルエミュレータは iTerm2 です。\nCtrl 2回押し で全画面に表示するようにしています。\n\nすぐに切り替えられて思考が飛ばないので気に入っています。\nフォントは  というのを使っています。\n\n数学記号系が非常に充実しているので、このフォントをいろいろなところで使っています。\n\nシェル\nシェルは fish を使っています。\nデフォルトでもいい感じの見た目・異常に補完が効くことなどが気に入ってずっと使っています。\n\n\nまた、アルファベット 2文字が枯渇するのではないかという勢いで異常な alias を貼りまくっており、 例えば  を  にする、みたいなノリで全てを 2タイプで終わらせています。便利かは不明です。\n\nエディタ\nエディタは Helix と VSCode を使っています。\n長らく VSCode ユーザだったんですが、最近は Helix でも結構書いています。\n\nJupyter Notebook, Coq, Markdown, LaTeX を書くときは VSCode, それ以外では Helix を使っています。\n\n脳にあるプログラムを文字にして書き込む、というパートはやはり Helix のようなモーダルエディタの方が速くできるだろうと思い練習中です。\nVim でなく Helix を選んだのは操作が体系的で覚えやすそうと思ったからです。 (逆張り精神もあります)\n\n一方で、 Helix はまだまだ未成熟でなんとファイルツリーすら表示できない！  ので、初見のコードベースをいじるときは VSCode を使っています。\nAI による支援をたくさん受けられるというのもあります。 Copilot Chat めっちゃ便利。\n\n\n\nHelix 自体の設定で特徴的なところを挙げるなら、\nDiagnostic を inline に表示するようにしている引数名や型推論の結果を Inlay Hints で表示するようにしている\nなどを設定しています。上だと 4行め, 30行めとかがそうですね。\nあとは Helix はテーマが結構オシャレなのがデフォルトでたくさん入っているのもいい点です。\nテーマで気分を変えるタイプで、 (VSCode にゆうに 300 個を超えるテーマを入れて毎日切り替えている) Helix はその点でも評価高いです。\n便利な VSCode拡張\nData Preview\n は、なんかやたらリッチなデータのプレビューができる拡張です。\n\n結構重いのであまり常に使える感じではないですが、小さいデータを見るときにはかなり便利でよく使っています。\nEaszy Snippet\n二秒でスニペットを登録できるやつです。\nDraw.io Integration\nVSCode で draw.io を使えるようにするやつです。　ブログ書くときに便利。\n便利な CLI ツール・Chrome拡張など\ndone\nやっていることの性質上、実行終了まで短くても数十分, 場合によっては数時間, 数十時間かかるプログラムをよく回すので終わったら通知してもらうやつが必要です。\n\n数日かかる系は流石にまともな Notification (Slack とか Discord に投げるやつ) を使いますが、簡単なものなら\n<a href=\"https://github.com/franciscolourenco/done\"><img src=\"https://gh-card.dev/repos/franciscolourenco/done.svg\"></a>\nで十分です。 これはある程度以上の長さのプログラムの実行が終わると Status と一緒に通知してくれる便利なやつです。おすすめです。\n\nnvitop\nGPU が焼き切れないか心配しながら日々計算を回していますが、モニタリングで便利なのが\n<a href=\"https://github.com/XuehaiPan/nvitop\"><img src=\"https://gh-card.dev/repos/XuehaiPan/nvitop.svg\"></a>\nです.\n\n\n\nかなりいい感じに CPU/GPU の使用率を表示してくれます。  を回すのはやめてこっちを使いましょう。\nGoogle Scholar PDF Reader\n は Chrome拡張なのですが、めちゃくちゃにおすすめです。\n\npdf を開くとまずこのようにいい感じに目次を出してくれたり、\n\nAI 要約をしてくれたり、また Google Scholar のマイライブラリに一発でグループ分けして追加したり、引用を一発で出せたり...とまぁ色々いいところはあるんですが、 個人的に一番革新的で感動したのは\n\nこの 夜間モード です。 いい感じに黒基調の色に pdf を変換してくれます！\n何がすごいかというと、\n\nこんな感じのも\n\n結構読める感じに変換してくれます！ \n基本的に寝る前にベッドで pdf を読んでいるので、 目が毎晩破壊され無事不眠症を発動していたのですが、 おかげでかなり楽になって本当に感動しました。\nなので普段はこれを使って pdf を読んでいます。\n翻訳系は昔は Readable を使っていたんですが、 ChatGPT だけで同等以上のことができると感じたので今はそちらのみを使っています。\n基本的に ChatGPT に投げて要約を読んで、細かいところを読みつつ英語がわからなったりしたら訳してもらったり、必要な前提知識をあげてもらったりしています。\nWakatime\n自分はあまり天才タイプではないので、なるべく長い時間計算機に触れたいと思っていて、 Wakatime を入れてその確認・モチベ維持をしています。\nWakatime は VSCode, fish はもちろん、Chrome拡張を入れて GitHub を見てる時間とかも測れたりするのでおすすめです！  毎日 10時間コーディング！(素振り) \n\nGitHub 関連\n他の GitHub 関連の便利ツールだと、GitHub のファイルにアイコンをつけてくれる  とか Contribution Graph をいい感じにしてくれる 　とかも使っています。\n\n飽きたのでこの辺にします。\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2dnYpOeH2Wg?si=JZvAku_8fJLjfGfR\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n 実際に動く実装もありますが、コアに入れずにプラグインとして実装するという方針になり、プラグインシステムがまだ未実装なので使えないという感じです。なので既存の実装を手元でビルドすれば使えはします。",
    "tags": [
      "開発環境",
      "アドベントカレンダー",
      "Helix"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "コミュニティコンペティションを開催するときの Tips 集",
    "post_date": "2024/12/01",
    "url": "https://abap34.com/posts/community_competetion_tips.html",
    "thumbnail_url": "https://abap34.com/posts/community_competetion_tips/IMG_3692.jpeg",
    "content": "\nあらすじ\n先月、大学のサークルで運営していた機械学習を勉強するコミュニティを後輩に譲りました: \n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">そういえば、大学のサークルの Kaggleコミュニティの長(?) を後輩に譲りました。<br>(抱えているプロジェクトがあるので、まだまだ色々しますが、一区切り)<br><br>2年半いろいろできて楽しかったです！ありがとうございました🙇‍♂️😊<a href=\"https://t.co/FTj9Ulm7dk\">https://t.co/FTj9Ulm7dk</a><a href=\"https://twitter.com/hashtag/trap1kaggle?src=hash&amp;ref_src=twsrc%5Etfw\">#trap1kaggle</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1846123877237150005?ref_src=twsrc%5Etfw\">October 15, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nここでは だいたい 2年半の期間で、だいたい 半年に一回くらいのペースで 計4回 コンペを主催して運営をしました。\n B1夏  17人      約200件   1週間  オンライン         B2春  30人      約200件   3日    オンライン         B2夏  37人      約750件   1週間  オンライン + 対面  B3春  114人     約1700件  1週間  オンライン + 対面 \nコンペを開催すると、機械学習の実践的な勉強になるのはもちろんですが、not 機械学習のエンジニアの人が参加してくれたり、やはりなんだかんだみんな楽しくやってくれて盛り上がるのでいいなぁと思っています。\n\n\nところで、コンペを運営する側の知見はあまり転がっていないので、はじめてコンペをやろうとすると、どういうことに気をつけるべきか、どういう工夫が世の中にあるのか、わからないがちです。\nそこで、後輩のためにコンペ運営のコツ、やった方がいいことなどを引き継ぎ資料として残しておこうと思っていたのですが、 特に企業秘密(?)にしておく理由もないのでここに書きたいと思います。\n(細い運営記録などは  などに転がっています.)\n\nTips 1. データセットの便利な探し方\nどんなデータを持ってくるか、そしてどんなタスクを解かせるかは、いうまでもなくコンペの面白さに最も大きく影響します。\n\n〇〇が好きな人が多いから、これをやろう！ ×× な会社だからこれにしよう！ のようにテーマが決まっている場合は特に書くことはないですが、とりあえず面白いコンペをやることだけが決まっていて、データセットの候補が特にない場合は何処かデータセットがまとまっているところから拾ってくることになると思います。\n\n自分の場合、以下のあたりをよく見ていました。\n\n個人的には Kaggle がデータセットのサイズやタスクで絞れたり使いやすいのでお勧めです。\nただ、Kaggle Datasets からとってくるときの注意として、 <span style=\"color: red;\"> 権利関係が明らかでないヤバそうなデータセットがちょくちょくあるので、この辺りのチェックが必須です。</span> \n元ネタであろうデータセットが Credit されていなかったり、そもそも本物なのかすら怪しいものがちょくちょくあります。\n本当の本当に身内でやる場合ならともかく、ちゃんとしたい場合は気をつけてください。\n\nなので\nKaggle Datasets でいい感じのテーマを見つける (アイデア出しとして使う)そのテーマのちゃんとしたデータセットを拾う\nというのが自分のやり方でした。\nTips 2. 人工データセットを使うことを検討しよう\n適当なテーマのデータセットを必ず手に入れる方法として、自前でそれっぽいものを生成してしまうというのもあります。\nメリットはライセンスなどを気にしなくていいこと、準備の工数が見積もりやすいこと、難易度含めタスクをいくらでも調整できることなどがあります。\n(とくに二つ目はかなり強いです。データ準備の期間を予測するのはかなり難しいです。)\n\nデメリットとしては致命的なリークを生みやすい、タスクの説得力が生まれにくい (データの生成方法を推定するだけのバトルになってしまうと楽しくない) などがパッとあがります。\n\nただ、初心者向けにとりあえず一回やってみる、というような場合はメリットがデメリットを上回ることも結構あると思います。 なので、そのような場合は人工データセットを使うのも一つの手です。\nTips 3. Starter Notebook を用意して、 Submit までしてもらおう\n初心者の人にコンペに取り組んでもらうには、とにかく最初のサブミットをしてもらって順位表に載ってもらうことが大事です。\nそこでまずは簡単な Solution を 完全に 実装した Starter Notebook を作ることをお勧めします。\n\nさらに、その Starter Notebook をほとんどそのまま実行してもらって Submit までやってもらうことも強くお勧めします。 やはり順位表に載って人を抜いたり抜かれたりすることは全ての人に有効なモチベーションになるからです。 (ランダムシードに好きな数字を入れて実行して投稿してみましょう〜　などがおすすめ)\n\n\n注意点として、初心者の人が多い場合、このような Notebook がコンペの方向性を本当の本当に決定づけてしまうこともあります。 (例えば、 LightGBM を使ったそこそこのスコアの Solution を提供してしまうと、全員が LightGBM のハイパラチューニングを 1週間しちゃうみたいなことがある) (1敗)\n\nStarter Notebook がよい Solution である必要は全くなく、Starter Notebook に工夫の余地を大量に残して、かつ選択肢を提示するのが大事です。\nTips 4. 質問対応をしよう\npandas でこういう処理をしたいけど分からない, こういうことをしたいけどライブラリを知らない etc などの理由で 改善を諦めてしまうのはもったいないです。\n\nですが、それをすべて質問できる一般的な形にしてもらって公開の場で質問してもらうのは初心者の人にとっては大変ですし、 毎回細かい話を Discussion にあげるのもハードルを感じる人が多いです。\n\nそこで、実装レベルの話であれば運営が質問に答えますよ、とした方がうまく回るというのが自分の考えです。 (もちろんアイデアの話などはちゃんと Discussion にあげてもらうのがいいです)\n\nTips 5. 簡単なサブセットを作ることで難易度を調整しよう\n多くの場合、コンペは\n初心者にとっては 1 Sub しやすく上級者は飽きない\nものであって欲しいです。\nそこでおすすめなのは、データのうち処理が簡単なものだけを抜き出したサブセットを作ってあげることです。\n例えば\n  　  \nのような典型的な構成のコンペでは  からパッと処理するのが難しい列を除いて、また  は行数を少なくして     のようなファイルを最初から配ってあげ、初心者の人はとりあえずこれを見てやってみてください、とすると良いです。\n\nEDA・学習含めいろいろ処理が早く終わってとっつきやすいというのもありますし、 初心者の参加者が普段使うソフトウェアで扱えるサイズにしておく ことで、 データ分析コンペの本質パートであるところの学習データを眺めて性質を考察する、というのを初心者の人でもやってくれて嬉しくなります。\nTips 6. Disucussion 賞を作ろう\nコンペ中に Disucussion や公開カーネルを出す文化は他のプログラムを書く競技ではあまりなく、ハードルを感じる人が多いです。\n\nそこで絶対おすすめなのが Disucussion 賞を作ることです。\n単に Upvote数で決めてもいいですし、運営が選ぶ、という方式でもいいです。\n\n前者は客観的で公平ですが、そうすると終盤に Disucussion を出す動機が希薄になってしまうので、 余裕があれば後者も作ってあげると序盤中盤終盤、隙がない Disucussion になるかと思います。\n\nTips 7. 順位表 bot を作ろう / なろう\nSNS で盛り上げることが、ありとあらゆる大会の盛り上がりで役立つことはもはや明らかな事実だと思います。\nそこで、順位表 bot を作って順位の変更通知を参加者が主に使う SNS に飛ばすことをとてもお勧めします。\n\nKaggle であれば Kaggle api で Community Competition でも順位表が取れるので、 これを定期的に回して差分があれば通知を飛ばす、というのが一番簡単かと思います。\n\nまた、実装する時間がない場合も、例えば毎日適当な日時に順位表のスクショと上位の人の告知などをするだけでもだいぶ違うかと思います。\nまた、これは自前プラットフォームを持っているときなどに限られますが、結果などを一発で SNS に共有できる機能があるとかなり便利です。\nTips 8. 振り返り会をしよう\nコンペ終了直後に振り返り会をしましょう！ この時間が一番勉強になりますし、コンペの盛り上がりをコンペを一過性のイベントでなくその後の盛り上がりと勉強に繋げる一番大事なイベントだと思います。(3敗)\n\nコンペ上位の人を表彰したり Solution を発表してもらったりするのはもちろん、やはり参加者同士であれがよかったこれはダメだったと話し合うのが一番大事だと思います。\n\n\nTips 9. チーム戦のすすめ\nもし参加者がそれなりに確保できそうなら、チーム戦にすることをおすすめします。\nこれは、チーム戦も可能ですよとする話ではなく、コンペの最初からチームを結成してやってもらう、ということです。\n\nいくつかメリットがあります。\nコンペの離脱率が格段に下がる同じチームの人と仲良くなるのでコミュニティが育つ単にコンペのレベルが上がる\nデメリットとしては\n参加者数が十分でないと少し順位表が寂しくなる場合によってはチーム内・チーム間の力量差が大きくなりすぎて一部の参加者のモチベーションが下がる\nというのがあります。\nなので、ある程度人数がいて、レベル感が大体同じなら迷いなくチーム戦前提、というのがうまく回ると思っています。\nもちろんソロでもチームでもいいですよ、という形でもいいのですが、特に短期のコンペだとチーム結成までのハードルが高いのでチームができにくく、 チームができて欲しい場合は最初からチーム戦としてやってもらうのがいいかなと思います。\nTips 10. コンペを健全にするために\nコンペを開催すると、どうしても不正する人が現れます。 身内に不正を指摘するのはかなり気が重いですが、 不正をずっとそのままにすると不利益を被るのは他の人なので心を鬼にして検知と指摘をしないといけません。\n\n例えば Private Sharing を検知するには、サブミッションの Correlation Matrix を作ってあげるなどすると良いです。\n\nまた、 Solution の公開を義務付けるとか、査収をちゃんとやるよ、とアピールするのも大切だと思います。 (振り返りにもなるので Solution を基本公開は大規模でなければ結構ポジティブな効果が大きいと思います) \n\nとはいえ、残念ながら完璧に検知することは当然不可能です。 不正をするやつは　😇 、という風潮をうまく作ることが根本的にアプローチする上でやっぱり大事かなと思います。\nおわりに\nほかにも、コンペの終了時刻を設定するときに UTC なことを絶対に忘れない (1大敗) などがあったのですが、 Kaggle ではアップデートで JTC で設定できるようになっていたので削除したりと、 コミュニティでコンペをやる環境は日々良くなっていていい話だなと思います。\n\nコンペ運営は大変ですが、やっぱり自分の設定したお題をみんなが解いているのは見ていて割と楽しいですし、 リークに気をつける力がつくのでオススメです。 (ただ、とくに序盤はとんでもないリークを仕込んでいないか気が気でないですが)\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PEnJbjBuxnw?si=9yMCnaCoGeXE5__m\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n",
    "tags": [
      "Kaggle",
      "データ分析コンペ"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "Julia Compiler Internals (05) - Algorithm of Type Inference [2]",
    "post_date": "2024/11/22",
    "url": "https://abap34.com/posts/jci_05.html",
    "thumbnail_url": "https://abap34.com/posts/jci_05/image.png",
    "content": "\nあらすじ\n今回もJuliaのコンパイラの内部実装を読んでいくシリーズです。\nシリーズ自体については  を見てください。\n\n は Julia の型推論について学ぶ前に、抽象解釈やデータフロー解析の基本的な部分をやりました。\n今回は前回見たデータフロー解析問題を解くアルゴリズムを実際に実装してその性質を調べます。\n\nさらに、世間の解説との diff として、停止性や正当性を含む各種性質の証明をすること、なぜこのように定義するのか？何が求まったのか？ などの解説をすることなどを試みてみました。\n\nただ、頑張って書いていますが、頑張ったからといって必ずしも誤りがなくなるわけではない 😢 (悲しい) ので、 あまり信用せずに読んでください。(とくに証明まわり)\n\n何かあれば一番下のコメントからお願いします。\n\nまた、単に頻繁にアップデートが入る可能性が極めて高いというのもあるので、事実の出典にはしないことをとてもお勧めします。 記事に末尾に読んだ文章をまとめておくので、正確な情報を得たい場合はそちらを参照するようにお願いします。\n\n準備 1 ─ プログラムの表現の実装\nプログラム自体の表現\n元記事で、 MacroTools を使ったパターンマッチングなどを活用したとても綺麗な実装があるのでそれを拝借させていただきます 🙏\n\nこういう 言語内 DSL みたいなのが簡単に書けると面白いですよね〜\n全然一ミリも本編に関係ないんですが、 MacroTools などを作った Mike さんという方は自動微分界隈で結構有名な方で、 Mike さんの書いた   という文章は本当に面白いのでおすすめです。\nMike さんのブログ:  にも本当に面白い記事がたくさんあります (例えば  とかおすすめです)\n\n本編に戻ります。\n元記事の 実装 > 問題設定で出てくる以下のコードをそれぞれ ,   とします。 実装はさておき理屈を知りたい方はかなり飛ばしても大丈夫です。\n:\n\n:\n\n\nこの部分は、よく見れば、そう。という感じでおそらく大丈夫だと思います。\n抽象的意味論の実装\nここからは abstract semantics  を実装していきます。 (元記事とほぼ同じです)\nまずは、そもそも  たちの evaluation がないことには何もできないので、それだけ一旦書きます。\n\n続いて、  の実装です。\n\nこれを  とします。\n準備 2 ─ 軽微な修正\nここから実際にデータフロー解析問題を解くアルゴリズムを実装しますが、 少し細々とした注意について見るために簡単なケースで実装してみます。\n定数の定義 ─ 制御構文がない場合を例に\nまずは、次のような Goto, GotoIf がないプログラムに対してうまく動かす例を考えましょう。\n\nここから見つけたいのは次の事実です:\n, ,  は定数になる\nここで注意ポイントですが、  は定数です。 \nここでいう定数というのはプログラムの中で最初から最後まで値が変わらない、という意味ではなく、 「ある命令前における値が条件分岐の結果に関わらず静的に決まる」という意味だからです。\n\nつまりこの場合では、 \n1つ目の命令を実行したあとは 2つ目の命令を実行したあとは 3つ目の命令を実行したあとは 4つ目の命令を実行したあとは \nということが分かりますから、 その意味では  は定数です。\nつまり、条件分岐がない valid なプログラムに対するデータフロー解析問題の解にはそのエントリポイントを除いて  が含まれないことになります。\nさて、これを求めるコードを書きます。\nまずは 抽象状態の初期値  を定義します。\n前の記事で見たように、これは\n\nなんでした。もう少し忠実に実装すると  とかで  とかすれば良さそうですが、今回は簡単のために手で全部書いてしまいます。\nプログラムと初期状態を受け取って実際に連立方程式を解く関数を書いてみましょう。\n今回は、  ですから、解くべき連立方程式は\nです。\nこれは単に  を順に計算すればいいだけです。\n\n結果は以下のようになります。\n\n無事に各命令の実行直前の抽象状態が求まっています！\n不正な遷移をどう扱うか？ ─ Unreachable な命令を例に\nここで、条件なしのジャンプ (Goto) が含まれるケースを例に実装上の一つの問題を考えます。\nプログラムの具体例として、以下のようなものを使います。\n\nこの場合の  を定義:\n\n\nにしたがって   について調べてみると \n\n\nということになります.\n\nこのまま実装すると\n\n\n\n\nこれで  が求まりました。\n続いて解くべき連立方程式を考えましょう。\n今回は\n\nを解かなければいけなくなったわけですが、 プログラムが無限ループにならないなら全ての  が  なので、例えば前から確定させていけば大丈夫です。\n\n(この部分は最終的には使わないのであまり考えず適当でいいです)\n\n\nこれを実行してみます。\n\nエラっています！ 右辺に  が入っているらしいです。\n\nエラーの原因は よく考えるとそれはそうで、  なので  をするとき  が Undefined で壊れています。\n\nもう一度   の実装である  を確認してみると\n\n\n引っかかる箇所としてはここの  になります.\n実は論文の定義をじっと見ると\n\n本当の本当にこの定義だけちゃんと見ると右辺に  があるときも  を返すべきとなっているように見えます。\n一旦これを信じることにしてみます。\n\n\nこれで実行してみると\n\nという結果になりました。\n が定数であることは見つけられていませんね... 😢\n\n正確には以下のように実装すると良いと思います。\n\n\n\nです。こうすると Unreachable なコードからの遷移は無かったことになります。  は meet の単位元だからです。\n\nつまりこの実装は 「不正な遷移は無視して、正しい遷移のみが実行される」という仮定にたったものといえます。\nこのことは、エラーを起こしうるプログラムに対する最適化でとても興味深い挙動を引き起こします。 この記事の最後で少し紹介します。\n\nまた、重要な事実として、このように定義すれば単調性も保たれていることに注意してください。\n\nこの実装で実行してみると\n\nと、ちゃんと  が定数であることが分かりました。\n\n準備 3 ─ データフロー方程式を再考する\n代入, Goto, GotoIf の全てがある場合を考えます。\n具体例として、次のような極めて単純なプログラムを例にして考えていきます。\n\nこの場合、解くべき連立方程式は\n\nです。\nこれを満たす  であって 各  が最大なものは\n 1                          2    1                           3               2                4               2                5               2                6    10               2               \nです。\n解が一意でないことに注意しましょう。例えば\n 1                          2    1                           3                          4                          5                          6    10                         \n\nも、実際上の連立方程式を満たします。 (欲しいのは一つ目の解です)\nプログラムの CFG を描くと\n\nみたいな感じになります。  を 3 までインクリメントするだけのプログラムです。\n\nこれが実行終了されるまでの経路を考えると、以下のようなものがあります。\n\nこの全ての経路の交わりを求めれば良いですが、これは見ての通りいくらでも考えられるので直接計算はできません。\n一旦これについてもう少し考察しましょう。 かなり手戻りになりますが、再度解の意味から考察することにします。\n理想の解と近似とそのまた近似\nプログラムのエントリポイントから  までの全ての 実際に実行されうる 経路の集合を  とします.\n  の元  は   のような経路です。\nここで、この経路によって得られる抽象状態は初期状態に全ての命令の作用の合成を作用させたものです. この合成した作用を  と書くことにします。 つまり、  です。\nそして、次のように を定義します。\n\n\nよく考えると、これこそが求めたい解です。ですが前回ではそのことを説明せず、これと異なる定義をいきなり与えました。\n定義をいきなり与えたのは、あの段階でここの議論をすると意味不明だったからですが、この定義を採用しないのは、残念ながらあるコントロールフローを実際通るのか判定するのは決定不能で、 は普通の計算機では一般には求められないからです。\n\nなのでここから解ける形に頑張って持っていきます。まず、次に以下のように定義される、  (Meet-Over-Paths) 解を考えます。 \n\n(実際に実行されるかは考慮せず、 CFG 上で到達可能という意味で) ずべての実行経路を  として\n\nとします。\nこのとき、   であり、 ,  なので  です。\n\nつまり、条件分岐を考慮しないのは理想の解よりも安全な見積もりであることがわかります。 経路を余分に考えても抽象状態はより安全側に倒れるだけということです。\n\nでは  は計算できるかというと、残念ながらこれも決定不能です。 \n証明を  に書きましたが、 もう少しざっくり議論してみます。\n\n何もわかっていない関数  によって終了するループを含む、以下のようなプログラムがあるとします。\n\nこのとき  の実行後の抽象状態、つまりプログラムの終了状態を求めることを考えます。\n は、  を実行する前の全ての抽象状態を列挙して、最後にそれらの交わりを取る必要があります。\nこれは上にも書いたように、経路がいくらでも考えられるのでナイーブに列挙して計算するのは不可能です。  として  が無限に列挙されて停止しません。 じゃあ単に  と違う値来た時点で  としてやめればいいのじゃないか、と思うかもしれませんが、\n\n\nとしたときは  が続くことになります。もちろん最後まで  が続きますから、 な訳ですが、 そう結論づけるにはどうすればいいでしょうか。\nループ回数を一つ増やしても  が続いたらそれ以降も  としていいでしょうか？\nもちろんそんなことはなく\n\n\nでは、\n 0                    1    -1   0    1                    2    -2   0    2                    3    -3   0    3                    100  -3   97   4                    100  -4   96   ...                  ...  ...  ... \nです。\nこのような、いくらでも大きな点で壊す例を構成できますから、結局どんなに  が続こうと定数と結論づけることはできません。\nなので後から交わりを取るならば、 ちゃんと が  の右単位元であることを証明する必要があります。 このレベルなら Coq を担いでこなくても示せるかもしれませんが、一般の複雑なコントロールフローに対してこのような性質を示すことは困難です。\nなので、  を計算することも無理でした。\n\nそこでまた、 に近い安全な解を求める方法を考えることにします。\n\nそれこそが前回定義したデータフロー解析で登場した方程式:\n\n\nです。\n求解アルゴリズム\n最大不動点を求めるアルゴリズム\n突然結論から述べますが、次のような実装のアルゴリズムで得られる解  は連立方程式の解です。\n\nこのアルゴリズムは、先行命令からの全てを命令を作用させた交わりをとる、というのを状態が変化するまで繰り返すというものです。\n言い換えれば、データフロー方程式の右辺を変化するまで繰り返す、つまりデータフロー方程式の不動点の一つを求めるアルゴリズムといえます。\n\n\nさて、いきなり出てきたからにはこのアルゴリズムはうまく働きます。\n\nそのことを証明します。\n解である証明\n\n は連立方程式の解である。\n\n\n連立方程式の解でないなら、  なる  があるので、  が更新されて  が終了しない。\nなので  は連立方程式の解。\n\n停止性の証明\n\nこのアルゴリズムは停止する。\n\n\n が  回更新されたときの値を ,  が  回更新されたときの値を  とかく。\n\nまず、次の補題を示す。\n\n\n\n\n が更新されるのは\n\n\nに限るのでこの更新だけ調べればよい。\n について帰納法で示す。\n\n1.  のとき\n なので、その最大性から成立.\n\n2.  のとき成立すると仮定\n仮定:  と  の性質から\n\nつまり\n\n作用の単調性から\n\nなので、結局\n\nこの補題から\n\n\nところで、束の高さの有限性から、ある  が存在して\n\nが成立する。このアルゴリズムはそのような  に達すると  ループが終了するので、アルゴリズムは停止する。\n\nまた、証明から、束の高さを  として 繰り返し回数は  で抑えられることがわかります. なので、変数の数を  とすると、このアルゴリズムの計算量は  です。\n\n最大の解であることの証明\n\n\nこのアルゴリズムで得られる解は、データフロー方程式の最大の解である。\nつまり、  がデータフロー方程式の解であるとき、 \n\n\n\nこのアルゴリズムの  ループ一回での  の更新を  とする。\nつまり、  は  から  の関数であって、\n\nここで、  上の半順序  を  として定めたとき、以下が成り立つ。\n\n は単調である。\n\n\n であることを示せば良い。\n仮定:  と作用の単調性から .\nすると、任意の  について、  の性質から\n\nなので . \n\nしたがって、以下を示せばよい。\n\n高さが有限の束  と、単調な関数  に対して、   なる  が存在して、そのうち最小のものを  とすると、  は  の最大不動点である。\n\n存在性は停止することの証明と同じ。\nここで、これが最大であることを示す。\n が不動点であるならば任意の  について  であることを  についての帰納法で示す。\n1.  のとき\n なので成立。\n\n2.  のとき成立すると仮定\n\n\n\nこれは、この図を見るともう少し直感的に理解できるかもしれません。\n\n単調なら順序が保存されるので、縦軸を大小関係  にして  で写した先と結んだときに交差することはありません。\nところで 不動点は不動点なので真横にいきます。もし最大の不動点以外に飛ぶとすると、真横に行く線と交わってしまいます。\nなので、  から  を適用していくと、最大不動点に到達します。\nしたがって、このアルゴリズムによって最大の解が得られることがわかりました。\n\n\nMFP 解と MOP 解の関係\n交わりと作用の分配性\n当然の疑問として、 との関係はどうなっているのか、そしてなぜデータフロー方程式なら解けるのか、という疑問が沸きます。\nまずは、 　と　 を比較して、「 とは交わりを先にとったものである」ということを強調しようと思います。\n\n\n例えば、経路が  と  の二つからなる場合を考えましょう。\nつまり、\n\nみたいな感じです.\n では、各経路について、先に全ての作用の合成を作用させて、最後に交わりをとっていました。\nつまり、\n\nです。\nこれに対してデータフロー方程式は\n\nなので、\n\n\nです。つまり、\n<img src=\"jci_05/image-4.png\" height=\"500px !important\">\nのように、  の適用と交わりをとるタイミングが入れ替わっています。 \n\nそして、このことから二つの重大な事実が導かれます。\n は常には成り立たない常に  である\nMFP != MOP なる例と解の一致条件 \n実際に、  が成り立たない例を示します。\n\nは、  と  が一致しません。これは\n\nというプログラムと対応しています。\nこのとき、 実際  はその実行経路に関わらず、定数  になり、 もそうなります。\n経路は\n\nのいずれかですが、\n\nなので、この交わりを取ると  は  になります。\nところが  は \n\nで、  なのでこれの交わりを取ると  になります。\nこれに  を作用させると当然  になり、  になります。\n\nこのように、交わりの適用タイミングが作用の前に来ることで、  と  が一致しないことがあります。 つまり、 このアルゴリズム  は最も具体的な抽象状態を必ずしも得られるわけではないことがわかります。　😢\n\n逆に、交わりと作用が\n\nを満たすときはは明らかに  です。　次回の記事でいくつか紹介するつもりですが、データフロー解析として定式化できる問題のうちいくつかはこの条件を満たしていて、 常に  が保証されます。\n\nところが定数伝播などはこの条件を満たさず、今回のような例が出てきます。\nMFP の安全性\nさて、  であることもあることがわかりましたが、ここで注意すべきは\n となるかどうかということです。この不等式が成り立つと言うことは、例えば定数とわからないはずなのに定数とみなしている、つまり誤った解を得ているこということになるわけで、静的解析としてはあってはならないことです。\n\nですが、幸いこのようなことは起きません。\n\nこのことは以下の定理によって保証されます。\n\n束  と、単調な関数  は、\n任意の  に対して\n\nを満たす。\n\n\n\n\nなので  の単調性から\n\nさらに  の定義から\n\n\n\n(実は、この逆 (不等式を満たすなら単調) も成り立ちます。)\n\nこの定理は、「先に交わりを取ると、より小さな ( 安全な) 解が得られる」ことを主張していますから、  であって、  が安全な解であることがわかりました！\n\nというわけで  解を少なくとも「使っても被害のない情報」として使うことができます！　\n\n今回は一旦ここまでです。\nおまけ:　未定義動作と最適化\n次のようなプログラムを考えましょう。\n\nこれは\n\nというプログラムです。\nこのとき、  が偽であって  が真であるような実行経路では  は Undefined で、実行時エラーか、言語によってはそもそもコンパイルが通らないでしょう。\nこのような場合どう推論するべきでしょうか？\n一つの考え方は「プログラムは正しい」という前提に立つことです。\nこの考え方のもとでは  が偽であって  が真であるような実行経路を考える必要はなく、  という定数伝播ができます。\n\nこのことは 今回の abstract semantics の実装と対応しています。\n\n実はていていのプログラミング言語では未定義変数はどのような値を取っても良いとみなして最適化することが許されていて、   はこういうのが (実際この場合どうなるかはともかく、同じ構造の理屈として) 一つの例なんだと思います。たぶん...\n\nまとめと次回予告\n今回はデータフロー解析の基本的なアルゴリズムの実装とその性質を調べました。\n\nところが元記事を読んだ人は、あれ、あのアルゴリズムどこで出てきた？となっているかもしれません。\n\n本当はそこまで書きたかったのですが、月曜日に期末テスト、水曜日と木曜日に締切のレポートを抱えているのに、このあたりの勉強とに夢中で一向に進んでいないうえに 日曜はライブに参戦するので、このままでは逆転留年を決めかねないため一旦ここまででやめます。\n次回は、このアルゴリズムを改良していき、元記事で紹介されているようなアルゴリズムへ到達するまでを調べる予定です。\nまた、定数畳み込み以外のデータフロー解析の例も紹介し、それの実装を示すことでこの抽象化の威力を確認しようと思います。\n\n参考にした資料\n(1) コンパイラ 原理・技法・ツール 第二版 \n9章のデータフロー解析の章を読みました。かなり最初から平易に説明してくれてとてもよかったので、まずこれを読むと良いと思います。MFP解 が最大不動点であることも証明が一応書いてあるんですが、証明になっているように見えなくて困っています。もし記述を完全に解釈できている方がいたら教えていただきたいです。\n(2) \n異常に詳しく、いくつかの証明はこれを参考にしました。 という本を書いている先生の資料らしく、この本は目次だけ見れるのですが、めちゃくちゃ詳しくかつ実践的で本当に欲しい 😭　ところがどっこい、お値段なんとびっくり ￥26500 のところ今なら ￥22500 らしいです。 もし読者に石油王の方がいらっしゃいましたらぜひ大岡山までご郵送ください。\n(3) \n(4) \n\n今日の一曲\nこっちの M.O.P. はギャングの名前由来らしいです。\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PLT68mI5Pwc?si=recMBvI2DLj4ktty\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "コンパイラ",
      "束論",
      "アルゴリズム",
      "抽象解釈",
      "データフロー解析"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Julia Compiler Internals (04) - Algorithm of Type Inference [1]",
    "post_date": "2024/10/21",
    "url": "https://abap34.com/posts/jci_04.html",
    "thumbnail_url": "https://abap34.com/posts/jci_04/image-2.png",
    "content": "\n小話\n@abap34 です。\n最近は腰と肩がかなり痛いです。いい椅子に座りたい 😢\nこの Julia 処理系を読む会もなんやかんや 2ヶ月くらい毎週続いているのですが、いくつかニュースがあったので本題に入る前に書いておきます！\nちょっとしたニュース ① \n先日 Julia の Co-Founder の  さんが来日されていて、なんとお会いすることができました。\n\nTwitterのリンクでも貼ろうかと思ったら Wikipedia のページがありました。すごすぎ。\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">It was such an honor to meet <a href=\"https://twitter.com/JeffBezanson?ref_src=twsrc%5Etfw\">@JeffBezanson</a> and fellow Julia compiler enthusiasts in Tokyo! <a href=\"https://t.co/r1vzPaP0X7\">pic.twitter.com/r1vzPaP0X7</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1846208258216022469?ref_src=twsrc%5Etfw\">October 15, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nそこで 「Julia の処理系を読む会を毎週やっていて、あなたが 10 年前に Scheme で書いたコードをみんなで何時間も読んでいるんです」と伝えたらとても喜んで貰えました！笑\n\nちょっとしたニュース ②\n第5回のコードを読んでいるとき、まだ SSA形式の IR になっていないはずなのに SSA形式の IR にするようなチェックがなされている箇所を見つけ、 「不思議だな〜」と話していたところがあったのですが、今日の記事にも登場する Juliaコンパイラの中の人であるところの aviatesk さんに聞いてみたところ、どうもミス (実際誤った挙動にはならないのでバグというほどでもないですが) っぽいという結論に至りました。\n読み始めたときにバグの一つや二つでも見つけられたらいいな〜と思っていたのでこれは嬉しいです。\n追伸: 修正のPRが作られて、マージされました。 \n\nいろいろといいことが起きてていい感じですね。今後も頑張っていきます！\n\n\n\nあらすじ\n今回もJuliaのコンパイラの内部実装を読んでいくシリーズです。\nシリーズ自体については  を見てください。\n\n は Julia の型推論について概観しました。\n\n今回は実際にアルゴリズムに踏み込んでいきます。\n具体的には、一旦 Julia のソースコードから離れて aviatesk さんの記事  を読んで実装しようと思います。 (以下 「元記事」とかきます)\n\nこの記事はなるべく元記事の理解の補足になることを目指しています。\n少し長くなりそうなので 2,3 個に分ける予定です。\n\nまず今回は前提知識や問題設定などについて書きます。\n\n(※ この記事の執筆は aviatesk さんの許諾をいただいて行われています。ありがとうございます！)\n\n束 (Lattice) の定義と具体例\n少しだけ使う概念の準備を書いておきます。\n束 (Lattice)\n\n集合  と  上の二項関係  が以下の条件を満たすとき、 を束であるという。\n が半順序である各  について  の上限と下限が常に存在する\nとくに  が有限集合のとき、有限束という。\n交わり(meet), 結び(join)\n\n束  について、\n に対して  を  と  の交わり (meet) に対して  を  と  の結び (join)\nという。\nこれだけだとパッとわかりにくいので、具体例を挙げてみます。\n束の例1: 論理関数\n束は割と色々なところに現れる構造です。\n\n例えば、自分は論理回路理論の講義で束に出会いました。調べたらあまり例に上がっていなかったのと、この記事のメインと構造が同じことに気がついたのででここで書いてみます。\n\n として、 ( です) \n な関数全体の集合を  とします。\n に対して次のように  上の二項関係  を定義しましょう:\n\nこのとき  は束です。\n確認してみます。\n が半順序であること: これは一つずつ確認すると、それはそうです に対して、 の上限と下限が存在すること:  とすると、これは上限です。  とすると、これは下限です。\n実際、例えば  の関数全体の集合は\n\n 0     0       0       1       1       1     0       1       0       1      \n\nからなるわけですが、\n以下のような図でその束の構造を表すことができます。\n\nつまり、ふんわり言うと束は上のような上下関係をいい感じの図にしたときに、どれをとっても下か上に辿れば交わるものと言えます。 (このような図を Hasse 図と言います。なお、全ての束が Hasse 図で表せるわけではないです  (例えば  と通常の大小関係))\nなのでこういうグラフが得られているのであれば   と  を求めるのは LCA を求める問題に帰着します。\n\n\n束の例2: Julia の型\nJulia の型と、その親子関係による順序関係も束をなします。\n を Julia の型全体の集合とし、\n \n\n二項関係  を次のように定義します:\n 型  が型  のサブタイプである\n\nこのとき  は束になります。\n上に載せた図を作ることで直感的に確認しておきましょう、 「Julia Type Tree」 とかで検索するといい感じの図が出てきます。\n\nおかしいです！ 束であるためには任意の 2つの元について下限が必要ですから、枝分かれのある木な訳がないです。\n\nしかし Julia の Concrete Type は サブタイプを持たないはずです。どう言うことでしょうか？\n\n──実は Julia の Concrete Type にサブタイプが存在しないと言うのが誤りで、  型と言う型が存在してこれは任意の型のサブタイプになります。\n( のオブジェクトは存在しません。型としてのみ存在します。)\n\n\nしたがって、任意の Concrete Type  に対して  となります。\nこの型の存在によって Julia の型の階層関係は束をなします。\n高さの有限性\nさて、今後この束でプログラムのさまざまな抽象状態を表現するわけですが、その計算の複雑性を考える上で非常に重要な特徴があるのでここで導入します、\n鎖 (Chain)\n集合  と  上の二項関係  を考える.\nここで、  が任意の  に対して  または  となるとき、  を鎖といい、  を鎖の長さという。 \n\n\n高さ\n最小元  が存在する半順序集合  の元  に対して、  の鎖の長さの最大値を  の高さという。\nさらに、  の元の高さの最大値を Lの高さ という。\n\n例えば\n\nなどは鎖で、長さは 3 です。\nまた、先ほど挙げた論理関数全体の集合がなす束の高さは 2 です。\n\nでは Julia の型 (に親子関係を入れたもの) は有限性条件を満たすでしょうか？\n実は満たしません。無限上昇鎖を作ることができます。\nこれについては今後見ていきたいと思います。\n\n\nさて、このように束は割といろんなところに現れる構造っぽいです。\nそして、実はプログラムのさまざまな要素・状態を束で表現することでいろいろな性質の解析ができます。\nここからはそれを具体的に見ていきます。\n抽象解釈\nJulia の型推論アルゴリズムは抽象解釈と呼ばれる手法を使っています。\nそこで、まずは 一旦 Julia の型推論のことは忘れて一般の抽象解釈についての話をしましょう。\n\nまず前提として、プログラムの調べたい性質は大抵の場合 Undecidable で、静的解析をするには常に諦めもしくはある程度の抽象化が必要になります。\n\nそこで、抽象解釈は読んで字の如し、プログラムをある程度抽象化して仮想的に実行することで、プログラムの性質を解析します。 つまり、抽象解釈という言葉は具体的なアルゴリズムというより、ある種のアプローチというかフレームワークというかを指す言葉です。\nこの抽象化の程度や方向性によって色々な解析をやっていくわけです。 例えば (役に立つのかはともかく、) 変数の偶奇だけに着目して「偶奇だけがわかるレベルで」プログラムを解釈して静的に偶奇の情報を得る、などができます。\n\n元記事では定数畳み込みを抽象解釈を使って行っています。この記事でもまずはこの例を検討してみます。\n抽象解釈による定数畳み込み: 問題設定\n以下のような機能を持つ簡単な言語を考えます。\n\n代入: , goto: 条件つき goto: , \n簡単のために、代入の右辺は定数か変数またはそれらの二項演算のみで、値は全て整数とします。\n例えば以下のような感じです。 \n\n<details> <summary>左についている枠について</summary>\n命令列の左に枠がついていますが、これは基本ブロック (Basic Block) というものです。 基本ブロックは、文の列であって、分岐も合流もない、つまり一つの入り口と一つの出口を持つものをいいます。\nこれによってプログラム全体の流れを表したものを制御フローグラフ (Control Flow Graph) と言います。\nプログラムが直列化されていれば goto, 条件付き goto によって分割することでこれが得られます。 (Julia では Lowering によってこれがされているんでした！このシリーズの過去記事を見てください。) </details>\nじっと見ると、以下のような処理をしていることがわかります。\n\n手で実行してみると、こんな感じです.\n\n 0    1  -  -  -    1    1  2  -  -    2    1  2  3  -   4    1  2  3  -   なので  にジャンプ  5    1  2  3  5    6    1  2  3  5   なので  にジャンプ  7    2  2  3  5    8    2  2  3  5   なので  にジャンプ  9    2  2  3  5    10    2  2  3  5   なので  にジャンプ  11    3  2  3  5    12    3  2  3  5   なので  にジャンプ  13    3  2  3  5    14    3  2  3  5   なので  にジャンプ  15    4  2  3  5    16    4  2  3  5   なので  にジャンプ  17    4  2  3  5    18    4  2  3  5   ではないのでジャンプはしない  19    4  2  3  5    20    5  2  3  5    21    5  2  3  5   なので  にジャンプ  22    5  2  3  5    23    5  2  3  5   ではないのでジャンプはしない  24    5  2  3  5    25    6  2  3  5    26    6  2  3  5   なので  にジャンプ  ...  ...  ...  ...  ...  ...  ...  45    10  2  3  5   でないのでジャンプはしない. 終了 \n\n をループカウンタとして使いつつ、最後の  回は  もする、みたいなコードです (これは何？)\n\nさて、ここから以下の事実を静的解析によって見つけることが目標です:\n\n<div style=\"text-align: center;\">\n, ,  は定数である\n</div>\nデータフロー解析の形式的定義\nこのあと具体的なアルゴリズムに入る前に、もう少し解こうとしている問題をもう少し一般化して定式化してみます。\n今回解きたい問題は、以下のように定義される 「データフロー解析」 と呼ばれる抽象解釈によって解ける問題の一つとして捉えることができます。\n\nデータフロー解析は、簡単に言えば次のような問題を解くことです。\n命令  の直前/直後の抽象状態として、最も具体的なものを求めよ。\n実際に計算機上で解くために、形式的に定義してみましょう。\n\nデータフロー解析 (Data Flow Analysis)\n\n命令全体の集合を  、プログラムの状態全体の集合を  とする。\n は \n代入 goto条件つき goto\nのいずれかに属する命令の集合。\n\nここで、以下のような四つ組  を考える:\n: プログラム (命令の有限列): 高さが有限の束: 各命令の作用を表す単調関数を返す関数 : 初期状態\nこのとき、データフロー解析は以下のような問題を解くことである:\n を\n\nと定めたとき、連立方程式\n\nを満たす最大の解  を求めよ\n\n少し補足をします。\n状態  のときに 命令  を実行したときの状態は  です (記法の確認です) が MathJax で使えなかったので  で代用しています。交わりの意味です。つまり、 連立方程式の各方程式はつまるところ「ありうる直前命令からの実行結果の全ての交わり」と言うことになります。 はややこしくなっていますが、要は命令  の直前になりうる命令のインデックスの集合になります。果たしてこれは最初に書いた「命令  の直前/直後の抽象状態として、最も具体的なものを求めよ」に対応する妥当な定義でしょうか？実はとても議論の余地、というか抜けがあります。次回の記事で議論するので、一旦ここは置いておいてください。元記事や  では  を その交わりと結びで定義していますが、ここでは準備に合わせて  としています。順序関係が  上で定まっていることに注意しましょう。 (後述します)\n\n定数畳み込みの形式的定義\n実際に今回の問題をこの定義に落とし込みます。\n\n上から行きましょう。\n1. \nちゃんと定義したければ BNF とかを書けばいいと思いますがいったんふわっと書くと\n\nみたいな集合です。全ての要素はそれぞれ 代入, goto, 条件つき goto のどれかただ一つに属することに注意してください。\n代入文の右辺には定数、変数またはそれらの二項演算がきます。( 項演算に拡張するのは容易ですが説明のために簡単にしています)\n2. \n次はプログラムの状態  とその順序関係  です。\n今回の設定では変数の状態以外に特に状態はありませんから、\n を変数の集合、  を変数の状態の集合として\n とすればいいでしょう。\n\n今さらっと  を導入しましたが、ここが (多分自分が思うに) キモです。 これの中身をどうするかが抽象解釈の設計の本質パート (ではないかとと素人ながら) 思います.\n\nというのもこの部分こそが調べたい性質のためにプログラムを抽象化するパートだからです。\n\n例えば今回の場合、次のような集合と順序関係を考えることによって抽象化します。\n\n として、  上の順序関係  を次のように定義します:\n\nこのとき  は束です。 \n\n図にすると\n\nみたいな感じです。\n はそれぞれ次のような意味です。 \n: 定数でない: 未定義\n\nこのような状態  を設定することで、実際の実行から、「定数かどうか && 定数ならその値」を考える抽象的な解釈に落とし込まれるわけです！ (たぶん)\n\n例えば (そんなもんが役に立つのかはさておき) 単に「定数かどうか」だけ調べるのであれば   みたいな感じでいいのだと思います。\n\nなお、注意する点として、 データフロー解析の問題設定においてはあくまでも束をなのは 各変数でなく状態  と  上の順序です。\nしたがって  上の順序関係を考える必要があります。\nが、そこまで大変でなく単に次のようにすればいいです。\n\nこれが束をなすのは論理関数のときと同じような感じでわかります！　(一般に、束の直積は上のように順序関係を定義することで束になります)\nなお、次の記事で使うのでここでいくつかメモ書きをしておきます。 (また、これ以降では記法の煩雑さ回避のために全ての変数が共通の状態  である抽象状態  を単に  と書きます.)\nmeet の単位元は  ですjoin の単位元は  です は有限性条件を満たします. (長さが最大の鎖は  です)\n3. \n構文は 3種類に分かれているわけですが、それぞれについて考えればいいです。\n[代入]\n としたとき、  以外の変数の状態は変わりません。\n右辺に現れるのが全て定数( ) であれば  も定数になりますから、   は次のようになります。\n\n\nとして、\n\n\n[goto]\n何も変わらないです。\n\n[条件つき goto]\n何も変わらないです。\n\n4. \n初期状態は全ての変数が  です。 元記事によれば元論文が間違っているとのことです。自分が一から読んでいたら気がつけないだろうことなので、ありがたいです。。。\n\nまとめ ！？\nこうして今回の問題設定をデータフロー解析の形式的定義に落とし込むことができました。\n\n次回は実際にこれを解くアルゴリズムを紹介します。\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/D0W44Z3D3wo?si=kvQ68VsF5tg-C5lC\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n 分野によって入れ替わることもあるみたいです。 ",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "型推論",
      "コンパイラ",
      "束論",
      "アルゴリズム",
      "抽象解釈",
      "データフロー解析"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Julia Compiler Internals (03) - Introduction to Type Inference ",
    "post_date": "2024/10/15",
    "url": "https://abap34.com/posts/jci_03.html",
    "thumbnail_url": "https://abap34.com/posts/jci_03/image.png",
    "content": "\nあらすじ\nJuliaのコンパイラの内部実装を読んでいくシリーズです。\nシリーズ自体については  を見てください。\nType Inference\n は Lowering について概観しました。\n今回からは Julia の型推論について概観します。\n\n今回は具体的な型推論アルゴリズムについて詳しく調べる前に、それ以外の部分について整理します。\nJulia の型推論について学ぶためにこの記事を読むのはオススメしません。\nもっと多くのことが、もっとわかりやすく、正確に書いてある文章があるからです。\n勉強記録を読む感覚でお願いします。おそらく間違いがたくさんあるので見つけたら↓のコメント欄にお願いします。\nもっと良い文章の例:\n\n\nWhat is Type Inference?\nまずは (Juliaにおける) 型推論とは何かを説明します。\n\nJulia は動的型付けのプログラミング言語です。実行時に  の型は定まります。\n一方で、 Juliaコンパイラは、各コントロールフローにおける変数の型を実際に実行する前に可能な限り推論します。\nそれによって最適化─ 例えば多重ディスパッチで実際に呼び出すメソッドを静的に解決したりします。\n\nさらに、Juliaの型推論は inter-procedural に行われていて、その関数の中で呼び出される関数にも飛んでいって解析を行います。\nこの辺どこまで潜るかのトレードオフは大変そうに見えますが、実際大変なようです。 \n\nExample\n例えば  という関数を考えます。\nこれは、  なら  が帰ってきます。\n\n マクロで実際推論できているのがわかります。\nさらに  なら  が帰ってきます。\n\n推論できてますね。さらに、内部的には　 と  が使われています。\n\nではもう少し意地悪な例を検討してみます。\n\nグローバル変数  を定義して　 とします。  は 6 と正しく計算できていますが、\n\nと、  となりました。  これは  の型を考慮した型推論は Julia は行わないためです。 (これがなぜかは分かりません。)\nさらに、出力をよく見るとこれまで特化した関数 (, ) が使われていたところが  になっています。\n\n( によって行われるものという意味で、) \nJulia の型推論プロセス全体は \n<div style=\"text-align: center;\">\n引数の実際の型　\n⬇︎ から、 \n各処理における型を推論 (推測ではない) \n⬇︎  して、 \n最適化を行う \n</div>\n ものと言えます。\n\nHow Julia's Type Inference Works (アルゴリズム以外)\nまず、具体的な型推論アルゴリズムに入る前に、一旦読むべきところだけ整理します。\n\n\n第 0 回で掲載した Julia の処理系の概観図を再掲します。\n\n\nJulia の型推論は、 Lowering されて得た IR に対して行われます。\n\n前回まででみたように IR は以下のようなものでした.\nマクロは全て展開済みループなども分解されて、全て直列の命令に書き換えられている\n\n型推論の「入力」はこれになります。  という型のオブジェクトです。\n\nと、こんな感じです。\n型推論の本質パートは ,  などにあり、  とその中身である  などを見ると良いです。\nこのあたりのフローはバージョン違いでかなり構造が変わっていました。初回記事に見ているコミットが載っているので確認してください。\nなんやかんやあるのですが、 (え？) 最終的にはおそらく  関数たちが実際に型推論を行っているのだと思います。\nなんやかんやはメモ用の scrapbox にあります: \n\nあまりにも中身がないですが、一応今回 具体的な型推論アルゴリズムについて詳しく調べる前に、それ以外の部分について整理する記事、なのでここまでです。\n\n(毎記事頑張って中身を詰めることにすると全然 Publish されなくなってしまうので...)\n\n次回は、 @aviatesk さんの解説記事を参考に実際の Julia の型推論のアルゴリズムについて見ていきます。\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/EsJGbHJyXYc?si=ICCQt996hR6xyQR5\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n https://techblog.recruit.co.jp/article-912/",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "型推論",
      "コンパイラ"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "2024年度前期振り返り",
    "post_date": "2024/09/30",
    "url": "https://abap34.com/posts/hurikaeri_2024_0.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/australian-shepherd/forest.jpg",
    "content": "\n2024年度前期の振り返り\n2024年度前期 (4月~9月) の振り返りです。\n\n去年の前期の振り返りは \n去年の後期の振り返りは \n\n作ったもの\nこのサイト\n<a href=\"https://github.com/abap34/abap34.com\"><img src=\"https://gh-card.dev/repos/abap34/abap34.com.svg\"></a>\nこのサイト  がリニューアルされました。\n個人的には記事検索画面  は結構気に入ってます。\n\nalmo \n<a href=\"https://github.com/abap34/almo\"><img src=\"https://gh-card.dev/repos/abap34/almo.svg\"></a>\n\n\nすいません、いつ v1 になるんでしょうか。\n\nそれはともかくいくつか重要な進展があり、\nPython 向けバインディングの提供とメインのインターフェースをそちらに移動パーサの根本的な書き直し 脚注の追加\nなどが行われました。 (44個の PR が mainにマージされました。)\n\nとくにパーサの書き直しは noya2 が、 脚注の追加は potato167 さんが Contribution してくれました。大感謝。\n\nPython 向けバインディングは自分が作業していて、 Python側から AST を操作したり、 Jupyter Notebook から変換したり、 jinja2 を使った拡張性の高いテンプレートの作成などができるようになりました。\n(今はその過程で見つかったパフォーマンス上の問題に対応するために、そもそものベンチマークの仕組みの整備などをしています。)\nこういう感じのコードが動きます。 (中身は全部 C++ です！)\n\n\nalmo に関連する記事もいくつか書きました:\n\n\nこれ書いてて思ったんですが、やっぱり早急にリンクカード欲しいですね。\nDacQ (-v2)\nデータ分析コンペのプラットフォームです。\n\n<a href=\"https://github.com/abap34/DacQ-v2\"><img src=\"https://gh-card.dev/repos/abap34/DacQ-v2.svg\"></a>\n\n\n軽率にやりたい放題コンペをやるために作りました。 \n記事: \nチーム戦を含めたコンペの機能、 Discussion 機能などがあります。\n\n\n実際にこれを使ってコンペをしましたが、なんとか致命的な不具合なく終わってくれてよかったです。\n\n\n\nml-lecture-judge\n\nオンラインジャッジです。\n\n<a href=\"https://github.com/abap34/ml-lecture-judge\"><img src=\"https://gh-card.dev/repos/abap34/ml-lecture-judge.svg\"></a>\n\n\n　 最初、既存の適当な OSS を動かそうと思っていたのですが、 PyTorch などを導入してのデプロイの手順が一生分からず、しょうがないので自分で作りました。\n\n\n問題は自分でも作成しつつ、後輩・同級生にも手伝ってもらえて楽ができました。大感謝。\n\n他にも、複数出力時のジャッジを konkoma が実装してくれるなどしました。大感謝。\n\nml-lecture\n以前から学部一年生向けに機械学習の入門資料を公開したいと思っていたのですが、ちゃんと書いて公開しました。\n\n<a href=\"https://github.com/abap34/ml-lecture\"><img src=\"https://gh-card.dev/repos/abap34/ml-lecture.svg\"></a>\n\nなるべく誤魔化したくない + なるべく完全に理解してほしい　の落とし所としてワントピックを掘り下げる感じで頑張って書きました。\n\n力作です。 あまり類似した資料はないと思います。 個人的にはこれにはとても満足しています。 　コンペ開催\n上に付随して講習会とコンペを一つやりました: \n大抵のことはこの記事に書いてありますが、\n38 チームが 1Sub 以上 (1チーム3人です！)合計で 1692 Sub\nと、今までやったコンペの中では一番大規模でした。\n\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">今日は機械学習講習会の第6回の講義とコンペの開会式(?) でした。ネットワークの攻撃検知を題材に1週間のコンペを始めました！！40以上のチームが組まれていて盛り上がっています🙌<br> <a href=\"https://twitter.com/hashtag/trap1kaggle?src=hash&amp;ref_src=twsrc%5Etfw\">#trap1kaggle</a> <a href=\"https://t.co/Q8OQLVJAxS\">pic.twitter.com/Q8OQLVJAxS</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1811009775033078126?ref_src=twsrc%5Etfw\">July 10, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n盛り上がってよかった。\n\n\n\n書いたもの\nブログなどを全て入れると多すぎてブロガーの振り返り記事になってしまうので、特に時間をかけたものだけ載せます。\n\n並列化時代の乱数生成\n擬似乱数生成は、数値計算・機械学習において欠かせない存在です。 また、現代においてはこれらの計算を並列化によって高速化することもまた重要です。\n\n一方で、単純な並列化は擬似乱数生成の再現性を損なうことがあります。\n\nこの資料は、まず擬似乱数・並列処理の基礎からはじめ、最終的には並列実行時に再現性を保つための手法について解説しています。\n\n具体例として、 Julia のマルチプロセス・マルチスレッドにおける擬似乱数生成器の状態管理の手法と実装を紹介しています。\n(コピペ)\n\n<iframe class=\"speakerdeck-iframe\" frameborder=\"0\" src=\"https://speakerdeck.com/player/c43f18061d8a4493968b8ddb9e67ab6f\" title=\"「並列化時代の乱数生成」\" allowfullscreen=\"true\" style=\"border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;\" data-ratio=\"1.7777777777777777\"></iframe>\n\nJulia Compiler Internals\nmrkn さんと antimon2 さんと一緒に毎週木曜日の夜に Juliaの処理系の実装を読む会をしていて、そこで知った内容をまとめるシリーズを始めました。 大体週に 1, 2本のペースで書いていて、今後も続けていくつもりです。\nJuliaLangJa の Discord で毎週開催しているので、興味がある方はぜひ 🤗\n\n\nその他・大学など何事もなければ 4年で卒業できそうです。 よかった.atmaCup #17 に参加しました。 (68/319 ...) NLPコンペは数年ぶりで、自分の知識が化石と化していることを痛感しました。ちゃんとキャッチアップします。大学の OS の授業がめちゃくちゃ面白くて、興味を持ちました。 それまでは知識も興味も全然なかったですが、 授業を受けてからかなり多くの文章がスッと読めるようになり感動しました。今後も割と真面目に勉強していきたいです。夏休みの前半に帰省して全ての親知らずを抜きました。歯が痛いだけで脳がまともなパフォーマンスを一切発揮してくれなく、人間弱すぎるなぁと思いました。東京ヤクルトスワローズは今年もダメでした。 東京工業大学が消滅しました。前期のコントリビューション数は 1982 Contributions でした。 ( してください)\n\nふりかえりと抱負\nなんとなく記事を見てみると Web っぽいものが多いです。  Web 系の知識は何も知らずに今までやってきましたが、 それこそ ChatGPT などのおかげでかなり学びやすくなって、低いクオリティのものならサッと作れるようになっていい話です。 (streamlit にもありがとう)\n\nとはいえ、自分にとって人と差別化できる要素だとは思っていないので、 後期はもっと機械学習・低レイヤ、、、 「発展させるために自分の人生を使っても良さそう」 と思っていることの勉強に時間を使っていきたいです。\n\nまた、それなりに (とくに、大学の) コミュニティに色々と返せたような気もするので、なるべく自分のために頑張りたいです。\n\nなんとなく以前より 「これ (計算機) で食べていくぞ」 という実感 (自覚?) が強くなってきました。\n正直に言うと、半年あったらもうちょっとできただろという気持ちがあり、自分の目指しているエンジニア像になれるか不安しかないので、後期は一層頑張ります。\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/u5KV0B0teIA?si=0OK8OPChXR6rfMIN\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n\n\n",
    "tags": [
      "日記",
      "振り返り"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "C++ のプロジェクトでいい感じの テスト・ベンチマーク・カバレッジ計測環境を構築する",
    "post_date": "2024/09/23",
    "url": "https://abap34.com/posts/cpp_ci.html",
    "thumbnail_url": "https://abap34.com/posts/cpp_ci/image-7.png",
    "content": "\nできるもの\n     \n\nはじめに\n人類はまだテストを不要とする技術を開発していないので、テストはいるんですね.  \n\nというわけでテストを書きます。 GitHub で C++ のプロジェクトをやることを想定して、\nGoogle Test でテストを書くGoogle Benchmark でベンチマークを取るそれの結果の推移の統計を GitHub Pages でいい感じに表示するCodecov でカバレッジを計測する\nあたりを整備する手順をまとめます。\n\n今回は Meson というビルドツールを使ってみます。\nドキュメントの先頭にはこんな感じのことが書いてあります。\n\nMeson is an open source build system meant to be both extremely fast, and, even more importantly, as user friendly as possible. The main design point of Meson is that every moment a developer spends writing or debugging build definitions is a second wasted. So is every second spent waiting for the build system to actually start compiling code.\n\nuser friendry, いいことばですね (ほんとに)\n\nドキュメントもいちおうあります.　\n正直あまり網羅的には書いてくれていない印象ですが... 😢 \n\n以下の Dockerfile で作った devcontainer で作業しています。\n\n\nとくに Mac の人は devcontainer でやるのがおすすめです。 (400敗)\n\nローカルでの環境構築\nサンプルプロジェクト\nこんな感じのプロジェクトを作ります。\n\n\n:\n\n:\n\n:\n\n3 つの数の総和を取る (ただし、前 2 つの和が 100 を超える場合は -1 を返す) です。\nMeson の設定\nMeson の設定を書きます。　とりあえず  を実行できるとこまで行きます。\n設定ファイルは  という名前で作ります。\n\n\n\n実際にビルドしてみます。\n\n で  にビルドディレクトリが作られます。\n\nそこで  でビルドが走ります。 (前までは  を直接叩くことになっていたようですが、今は  で適切にバックエンドを見つけてやってくれるみたいです)\n\n\nというわけでビルドが終わると、\n\n無事に実行されました！　\nGoogle Test の導入\nまずは  で.... もしくは  の  で... ではなく、 なんと Meson は wrapdb というところにいろんなライブラリを置いてくれていて簡単にとってくることができます。\n\n\n\n で取れます。\n早速 Google Test を取ってきます。\n\n\nすると、  というファイルができていて、\n\nではこれを使ってテストを書きます。\n\n を作ります。\n\n にテストの設定を追加します。\n\n を一旦消して再度ビルドすると、\n\nヨシ!\nGoogle Benchmark の導入\nGoogle Benchmark も同様に  で取ってきます。ありがたい...\n\n\n を作ります。\n\n にベンチマークの設定を追加します。\n\nビルドして実行すると、\n\n\n無事にベンチマークが取れました！\nカバレッジ計測\n最後に、カバレッジの計測をします。\n\nなんと Meson は Meson のレベルでカバレッジをよしなにやってくれます。\n順番に見ていきましょう。\nまずは、カバレッジ用のビルドを作ります。\n\nすると、例えば \n\nのように、  ファイルができています。 \n\nではテストを実行してみます。\n\nすると、例えば\n\nと、  ファイルが無事に生成されています。\n\nそうしたら、カバレッジレポートを生成します。\n\nすると、  が生成されます。\nこれを開くと...\n\n無事にカバレッジレポートが生成されました！　(´・ω・｀)🎉\nGitHub Actions で CI する\n最後に、これを GitHub Actions で継続的に行うようにします。\n(ここから出てくる Action は  などは適当なので適宜必要なものに変えてください)\nテスト\nまずはテストを走らせるようにします。\n依存ライブラリをまとめてインストールするスクリプトを書きます。\n\nあとは適当な Action を書きます。\n\nすると、\n\nこれで PR時にはテストが走るようになりました。\nベンチマーク\n続いてべンチマークを走らせるようにします。\n\nという素晴らしい　Action があるのでこれを使います。\nこの Action を使うと、\nベンチマークの結果をコメントに書くベンチマークの推移を記録して GitHub Pages に表示\nなどができます。\n\nREADME.md にしたがって、このアクションで使えるように結果を吐く、以下のような Action を書きます。\n\n\nすると、\n\nこんな感じで、各コミットに対してベンチマークの結果を教えてくれます。\nさらに、例えば  を\n\nこんな感じにして 1秒の  を入れてものすごくパフォーマンスを落とすようにしてみると、\n\nテストが失敗します！便利！\n\nさらに、  ブランチを生やしておいて、 GitHub Pages を gh-pages 起点で作るように設定しておくと、\n\nパフォーマンスの推移を見られるページが生成されます。便利。\nカバレッジ計測\n最後に、カバレッジ計測を Codecov で行うようにします。\n にいって　Key をもらい、 Secrets に登録しておきます。\n\n本当に計測する部分はもうできているので、あとはそれを XML 形式にエクスポートして Codecov に渡すだけです。 公式の example や色んな情報を見ると  のような事をして直接(?) しているものが多いですが、以下のように Actions 経由で渡す方が色々設定できて圧倒的に良いと思います。\n\n\nするとこんな感じでカバレッジ計測結果が見られます　(´・ω・｀)🎉\n\n\n などがテストできていないことがわかりますね。\nまた、新たに PR を出すと\n\nカバレッジの変化が見られます。便利。\nまとめ\n\n実は最初は CMake + devcontainer なしでやろうとして本当に酷い目あったりしていました。\n(例えば、ちゃんと  な事をしても  は Clang 用のものがデフォルトでは実は使われていて、、、などのパッとわからない依存がたくさんあり、大変なことになっていました。)\n\n令和の世の中、プログラミング言語はもはやそのものではなく、パッケージマネージャ、ビルドツール、エディタの支援 etc... によって差がつく、みたいなことが言われて久しいですが、それをひしひしと感じる作業でした。\n約2日間、「C++ やめていい？」しか言っていなかったです。\n\nとはいえ、 Meson は結構いいものを知ったなという気持ちです。これで色々と開発を便利にしていきたい。\n今日の一曲\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" allow=\"autoplay\" src=\"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/1591947091&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true\"></iframe><div style=\"font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;\"><a href=\"https://soundcloud.com/koshy-226161802\" title=\"Watson (Official)\" target=\"_blank\" style=\"color: #cccccc; text-decoration: none;\">Watson (Official)</a> · <a href=\"https://soundcloud.com/koshy-226161802/mj-freestyle\" title=\"MJ Freestyle\" target=\"_blank\" style=\"color: #cccccc; text-decoration: none;\">MJ Freestyle</a></div>\n  より.",
    "tags": [
      "C++",
      "CI",
      "GitHub Actions",
      "Google Test",
      "Google Benchmark",
      "Meson"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "Julia Compiler Internals (02) - Lowering (2) for の linearize",
    "post_date": "2024/09/21",
    "url": "https://abap34.com/posts/jci_02.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/dachshund/Dash_Dachshund_With_Hat.jpg",
    "content": "\nあらすじ\nJuliaのコンパイラの内部実装を読んでいくシリーズです。\nシリーズ自体については  を見てください。\nLowering\n は Lowering について概観しました。\n今回は、Lowering における for文の処理について少し書きます。\nfor の出自\nfor はいうまでもなくトップクラスに使われる制御構文ですが、 Juliaにおいては for は以下のような対応の糖衣構文です。\n\n\n\n(このあたりのことは、  さんに教えてもらいました。ありがとうございます。)\n\n は前回見たように  でバラされていましたが、この糖衣構文を desugar するのはどこでやっているのか見てみます。\ndesugar\ndegugar は  で行われています。\n例えばわかりやすそうなのでいくと  に\n\nとあります。\nこれは  という糖衣構文を  に desugar する処理です。\nこのまま見ていくと  に 以下のようなものを見つけることができます。\n\n\nちょっと長いですが、 どうも for を先ほどの while に書き直す処理がなされていることがわかります。\nなので、 for は\ndesugar → (while として)  というながれで AST から linearize されて IR になることがわかりました。\n\nまとめ\nヤクルト最近ちょっと強いですね〜\n今日の一曲\n何かの間違いでヤクルトに入団してほしい。\n\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BtH57Tku3qY?si=aMpxcnxTpfFvwmbf\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "Scheme",
      "コンパイラ",
      "Lowering"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Julia Compiler Internals (01) - Lowering (1)",
    "post_date": "2024/09/20",
    "url": "https://abap34.com/posts/jci_01.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/pinscher-miniature/n02107312_3980.jpg",
    "content": "\nあらすじ\nJuliaのコンパイラの内部実装を読んでいくシリーズです。\nシリーズ自体については  を見てください。\nLowering\n は Juliaの処理系の大まかな流れを見ました。\n今回からは、各セクション (Lowering, Type Inference, ...) の処理の大枠を見ていきます。\nWhat is Lowering?\n前回も書きましたが、 Lowering は AST を もう少しネイティブに近い IR に変換する処理です。\n例えば、\n\nは\n\n\n\nと、  ループが 直列に展開されているのがわかります。\n\njl_expand\n を見てください。\n\nこのように Lowering は  によって行われます。　\n に定義があります。\n\nと、結局  が呼ばれています。    \n では gc・マクロ展開関連の処理もありますが、今回は  に集中することにします。\n では Scheme で書かれた Lowering の処理がよばれます。\n\n(ちなみに、最近では Juliaでこれを書き直すという取り組みもあるようです。)\ncompile-body\nScheme側ではなんやかんやあって最終的に  にある実装たちが本質パートを担当してくれます。\nこのファイルは 5000行以上あってかなり大変な見た目をしていますが、やっていることをあたるにはおそらく  を見れば良さそうです。\n\n\n一旦、 Lowering でおそらく一番核心的なことである制御構文をバラして直列にしているところ (= ) だけ注目してみることにします。\nするとこれは  という関数がやってくれいていることを読み取れます。\n\n\n を見ましょう。  です。\n\n... 長い！！！ (700行↑)\n\n一旦真面目に全部読むのは後に回すとして、処理の概略を雰囲気で読み取ることを試みます。\nまず、先頭ではラベルのカウンタとかが置いてあります。 これを使って goto のラベルを作っているように見えますね。\n\n\n続いて、例えば L4663 を見ます。\n\n\nどうも  がジャンプに書き換えられていそうです。\n実際、\n\n\nですね。 最初に見た  で goto のラベルを作っているのがわかります。\n\nこのような定義が前後で延々と続いていて、どうも素直に制御構文ごとにバラし方を考えて、順番にバラしているようです。\n\nまとめ\njulia-syntax.scm の blame をみるとわかるんですが、 10年近く前に Jeff さんが書いたコードが大部分を占めていてすごい。\n\n... すごいんですが、やっぱり読むのはなかなか骨が折れるので、 Juliaによる書き換えには期待したいところですね。\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/d0ARerCxF8c?si=Gz4RV12QlRHvTJgH\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n\n JuliaLowering.jl というのがあるみたいです。 (まだ experimental)    ",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "Scheme",
      "コンパイラ",
      "Lowering"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Julia Compiler Internals (00) - Introduction",
    "post_date": "2024/09/18",
    "url": "https://abap34.com/posts/jci_00.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/australian-shepherd/pepper.jpg",
    "content": "\nはじめに\n先日から Julia の内部実装を読む会を始めたのですが、そこで得た知識をここにまとめていこうと思います。\nすでに scrapbox にメモ書きが生えているのですが、それを再構成してもう少しちゃんと文章に書いていきます。\n短い記事の集まりになる予定です。\n\n前提\n読んでいるコードやドキュメントは全て Julia 1.11-rc3 (コミット: 616e45539db4c49ab019b7ccd318800f240743f6) のものです。なるべく正確になるよう頑張りますが、誤り等あればコメントで指摘していただけるとありがたいです。解説記事というよりメモ書きに近い形態です。 コンパイラや Julia に関する知識を割と前提にしています。\n目標\n一応、 Julia の IR・最適化周りをきちんとめに理解する ことを目標にしています。\nそのため、 例えば\nパーサ周りマクロ展開まわり\nについてはそこまで深くは追求しないことになりそうです。\n目標としてこの辺りを定めたのは\n現代の自動微分ライブラリ:  や  あたりをきちんと理解したい。「Julia ってなんで速いの？」 に対する回答を常に適切な粒度でできるまできちんと理解したい。\nあたりによるものです。\nなのでこのあたりに関心がある人は面白いと思います。\n00. Julia の処理系の大枠\n\nJulia がコードを実際に実行するまでの流れをざっと理解します。\nパース\nソースコードはまずパースされて AST に変換されます。\nSyntax Error 周りがかなり見やすくなったので気がついた人も多いと思いますが、 Julia 1.9 までは lisp で書かれたパーサが使われていたのが、Julia 1.10 からは  がデフォルトになりました。\nマクロの展開\nJulia のマクロはこのタイミングで展開されます。\nそのため、この後出てくる型推論の結果などをマクロに反映させることは難しいです。\nLowering\nAST は Lowering という処理を経て、 IR に変換されます。\nAST と IR の違いですが、 IR の方がかなりネイティブに近い形式になっています。\n実際に見るのがわかりやすいと思います。\n例えば、\n\nの AST は\n\nと、そのままループ構造が残っていますが、IR に変換されると\n\nと、ループ構造が  とかで書き換えられているのがわかります。\n\nInfer types \nこの IR に対して型推論が行われます。\nここがおそらく今回のシリーズで一番難しい部分になるかと思います。 今書けることといえば\n とかで型推論の結果を見ることができますよ、くらいでしょうか。 　\nSSA Convert\nJulia は最適化のために IR を SSA形式の IR に変換します。\nOptimize\nここも難しそうです。\nSSA形式の IR をこねこねすることで最適化を行います。\nTranslate\nJulia は バックエンドとして LLVM を使っています。\n得られた最適化された IR は LLVM IR に変換されます。\nGenerate\n最後に、LLVM IR からネイティブコードが生成されます。\nまとめ\nがんばっていきたい。\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/tcV1IIARPX4?si=7F0HxxLLAqT8Arpk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "JuliaCompilerInternals",
      "Julia",
      "コンパイラ"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "脚注機能の実装に関するメモ",
    "post_date": "2024/08/07",
    "url": "https://abap34.com/posts/footnote_implement.html",
    "thumbnail_url": "https://abap34.com/posts/footnote_implement/thumbnail.png",
    "content": "\n脚注機能の実装に関するメモ\n最近、このブログを作ってくれている Markdownパーサである almo  に脚注を実装しました。\n(まさに今つかったこれです)\n\n脚注は、 Common Mark  でも GFM 　でも定められていない構文ですが、長いドキュメントを書くときには結構欲しくなります。\n\n\nところで、脚注はパーサを書くことを考えると他の構文と比べてやや異質な存在です。\nそのため実装の仕方に割と幅があります。　\nこの記事では almo の脚注の実装方法とどうしてそうなったか、というのを日記がてら振り返りたいと思います。\n脚注の何が特別なのか？\nそもそもたいていの md2html な処理系たちはたいてい次のようなフローで処理を行います。\nMarkdown をパースして AST に変換AST を走査して HTML に変換\nalmo も同様です。\n\n例えば\n\nのような md ファイルを almo に渡して、\n\n\n してみると\n\nという結果が吐かれてます。\n\nここから HTML に変換するわけです。\n\nここで、パースするとき・この AST から HTML を生成するとき　のうれしい性質として、「各ノードは独立に考えてもいい」というのがあります。\n\n例えば HTML に変換するときは、それぞれのノードは (他のノードが valid な出力をしてくれているという前提に立って)、　自分が正しい出力をすれば良いだけです。\n\n\n<span class=\"lined\">しかし、脚注は違います。</span>\n\n\n脚注は以下のような性質があります:\n定義は末尾に生成される番号を振る未定義な脚注がないかチェックする\n\nしたがって、 AST 全体にわたるグローバルな状態を検査する必要があります。\nこれが脚注の他の構文との違いです。\n\nどう実装するのか？\n最初に自分が提案したのは、パースをする際に使う  にグローバルな状態を持たせてパースさせていくことでした。\n\nというのも、実は類似の仕組みがすでに実装されていたためです。\nこれは almo 特有の事情ですが、Pyodide をロードするのは非常にコストがかかるので、不要ならこれをスキップするために 「Pyodide が必要か？」というのを調べるために  クラスに情報を持たせる仕組みがすでにありました。\n\nそのため、自分は当初これと同様の実装を提案しましたが、一緒に開発している友人から別の仕組みを提案されました。\n\n\nそもそも、  クラスにあまり情報を持たせるのはうれしくありません。 この手の構文が増えるたびに肥大化していくのが目に見えています。\n\nそこで、脚注の実装を AST に対する後処理として行うことを提案されました。\n\n\nつまり、 (第一段階の) AST を作る段階では末尾に移動させる、正しい脚注定義がなされているかをチェックする、などの処理は行わず、 AST が完成した後に走査・操作を行なって所望の結果を得る、というものです。\n\nこの実装で統一することで 「Pyodide が必要か？」という処理も単に特定のノードが含まれるかを最後にチェックするだけに書き直して、割とスッキリした実装になりました。\n\n実装\n　では、\n\n\nという感じで、 脚注のノードを末尾に移動させる処理を行っています。　便利！\n\n感想\nこんな感じの流れでこういう実装にしたんだよね、という話を 同じく自分のブログのためにマークアップ言語を作っている別の友人に話したら、 「全く同じ議論で全く同じ方式に行き着いた」と言われてびっくりしました。　\nおもしろいもんですね 🤗\n\n今日の一曲\n最近雨やばいですよね\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/yEpKC0wXy4M?si=MvIcU92Y6I_1f1rt\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n\n   ",
    "tags": [
      "日記",
      "Markdown",
      "ALMO",
      "AST"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "オンラインジャッジを作った",
    "post_date": "2024/07/01",
    "url": "https://abap34.com/posts/oj_abap34.html",
    "thumbnail_url": "https://abap34.com/posts/oj_abap34/image.png",
    "content": "\nあらすじ\nオンラインジャッジを作ったので紹介します。\n作ったもの\n\n\n\n\n\n経緯\n今年も traP で機械学習講習会をしているんですが、せっかくなので演習問題にジャッジがつけたくなりました。\n既存の OSS を使うことも考えたのですが、デプロイの仕方や実行環境の追加の仕方を調べるのがあまり楽しくなさそうだったこと、 traPの認証との連携も面倒そうというあたりから、自分で作った方が早いだろうという判断で作りました。\n技術スタック\nフロントエンド: React (Vercel でホスティング) バックエンド: FastAPI (家のサーバから ngrok でトンネリング)\nフロントエンドについて\nReact です。 \nMaterial-UI でかなり楽ができて感動しました。\nバックエンドについて\nFastAPI です。 とくにジャッジ周りは非同期処理が多いですが、FastAPI だとそのあたりがかなり簡単にかけてすごいな〜と思いました。\nまた、性質上同時に大量に提出される場合があるので、適切にジョブをキューイングする必要があります。\n幸いこの知識だけはあったので、 ジャッジのジョブはCelery と Redis を使ってキューイングして、適切な並列度で実行されるようになっています。 これによって大崩壊するほどの実行時間のブレを防ぐことができます。 (ちゃんとしたジャッジは複数回実行など、もう少し真面目にやっていそうですが)\n実際のコードの実行では、ユーザのコードをそのまま実行するわけにはいかないので、 Dockerを使ってサンドボックスを作り、その中で実行します。\nコンテナランタイムの知識があまりないのでセキュリティに対して絶対の自信があるわけでは正直ないのですが、幸い Library Checker のジャッジシステムが公開されていて比較的読みやすかったので、 それを大いに参考にして実装した結果、ある程度典型的な攻撃は防げるようになりました。\n<a href=\"https://github.com/yosupo06/library-checker-judge\"><img src=\"https://gh-card.dev/repos/yosupo06/library-checker-judge.svg\"></a>\nデプロイについて\nフロントエンドは Vercel です。\nAPIサーバですが、家のサーバで立ち上げて ngrok でトンネリングしています。\n稼働するのが高々2週間程度の予定なこと、ジャッジを高速にできるようそれなりのスペックが欲しいこと、そして どこかに必ずバグを仕込んでいる確信があったので、停止したとき素早くデータを救出できそうなこと などを鑑みて ngrok を使ってみました。\n感想としては、かなり良かったです。お手軽かつ安定していてログも見やすいですしかなり気に入っています。 今後も短期的にサービスを公開するときは使っていきたいと思いました。\n最後に\n今は認証が traP に依存しているので、その辺を独立させて公開する予定です。\n今日の一曲\n昨日シブツタでCD買いました。\n渋谷より東に進出できるようになりたい。\n\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KYvq8-xY1Gg?si=xbxsze8kJfULjrbI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "日記",
      "Web",
      "FastAPI",
      "React",
      "Docker"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "最急降下法の収束定理の主張とその証明",
    "post_date": "2024/06/30",
    "url": "https://abap34.com/posts/gd_convergence_theorem.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/kombai/Kombai-indian-Dog.jpg",
    "content": "\nあらすじ\n最近 Webとかあまり慣れていないことばかりブログに書いていたので、数学の話をしようと思います。\nまず、数理最適化の授業で頑張って勉強したものがあんまりテストに出なくて悲しかったのでブログにすることで供養しようと思います。\n最初は、ならったもののうち一番印象に残った定理について書きます。  (ちなみにこれはテストに出ました。)\n前提: 直線探索\n直線探索は　 になるまで以下のように更新を繰り返すアルゴリズムとします.\n\n(ここで、  は  を最小にするような  です)\n\nさて、 が凸であるとき、  なる  は  の大域的最適解です。\n(勾配不等式:  について  とするとわかります)\nしたがって、 凸関数  に対して、それなりに小さな  を取ることで最適解を得ることを目指すことができます。\nところで、大域最適解が存在する一般の  について直線探索は終了するとは限りません。　\nここでは、とくに  の勾配に条件をつけて、そのときの収束性とその反復回数についての保証を与える定理を紹介します。\n\n最急降下法の収束定理\n\n最急降下法の収束定理\n 級の関数  について、 大域的最適解  が存在し、  がリプシッツ連続であるとする。\n\nこのとき、 回以下の反復で、 直線探索は終了する。\n\n(  は  のリプシッツ定数)\n\n\n収束の保証だけでなく、速度まで主張していてとても強いです。\nさっそく証明をしてみます。\n\n証明\n次のような方針で証明を進めたいと思います。\n方針\n[1]  がリプシッツ連続であるとき、次の不等式が成り立つことを示す\n\nこの不等式を使うことで、各反復での更新を評価することができます。\n\n[2] 各反復における更新の評価を使って   までの反復で収束条件を満たすことを示す\n\nそれでは、1. からいきます。\n\n がリプシッツ連続であるとき、次の不等式が成り立つ。\n\n\n\n を  について微分すると、\n\n\nすると、\n\nしたがって、\n\nよって、\n\n\n\n以上で補題1.が示されました。\nこれを使って各反復での更新を評価していきます。\n\n各反復での更新の評価\n を直線探索による最急降下法によって得られる点列とする。\nこのとき、次の不等式が成り立つ。\n\n\n\n\nLemma1. について ,  として\n\n\n\nここで、直線探索で最小化するように選ぶ  に対して  であることを使うと\n\n\nすると\n\n結局\n\nよって\n\nしたがって、\n\n\n\n\n\n\n以上で補題2.が示され、各反復での改善幅をリプシッツ定数で評価することができました。\n続いて、これを使って  回反復したときの改善幅を考えます。\nM回反復の評価\nlemma1. を  から順に  回適用すると、\n\nが得られます。\nさらに、 は大域的最適解であるので、  が成り立ちます。\nしたがって、\n\nです。\n収束回数の評価\nいよいよ最後です。\n各  に対して、  を \n\nを満たすただ一つの自然数として定めます。\nこのとき、  について  と仮定します。\nすると \n\n\nしかし、 の定義より\n\nなので、結局\n\nが成り立ちますが、これは (2) と矛盾します！\nしたがって、  を満たす  が少なくとも一つ存在します。\nこれが示したかったことでした。\n\n感想\n俺はお祈り勾配降下法をやめるぞ！！ジョジョー！！！  (ここであまり理解していない謎の Warm up をペタリ)\n\n今日の一曲\n東京ドームライブ行きました。よかったです。\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Rs-Y9MtHsoo?si=POEXpQZVHFLE3TRh\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n参考文献\nだいたい同じ話が載っています。山下信雄, and 上田健詞. \"制約なし最小化問題に対する勾配法, ニュートン型手法の反復回数の見積もり.\" 日本オペレーションズ・リサーチ学会和文論文誌 56 (2013): 15-30.\n",
    "tags": [
      "数学",
      "最適化",
      "機械学習"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "pybind11 を使って C++の関数をバインドして Pythonから呼び出す (m1mac)",
    "post_date": "2024/05/14",
    "url": "https://abap34.com/posts/pybind11.html",
    "thumbnail_url": "https://abap34.com/posts/pybind11/image.png",
    "content": "\nことの経緯\n今日も自作マークダウンパーサである  の開発をしています。\n昨今の機能拡張にともなって色々なライブラリを使いたくなってきたのですが、 C++のパッケージマネージャにあまりちゃんとしたものがなく、C++を使うのがかなりしんどくなってきました。\n\nRust とかで書き換えるのは個人的にありでしたが、開発メンバは C++ なら書けるという人が多い (というか、それが C++で書かれた理由です)　ので みんなに働いてもらうためにもあまり大幅な変更は避けたいところです。\n\nというわけで、最終的に現在の内部実装には手を入れず、外部から Python で呼び出せるようにすることにしました。\n\n実際にパースするところなど、パフォーマンス的に重要な部分は今の C++で書かれたままにして、  Front YAML のパースやリアルタイムのプレビュー、 Jupyter Notebook の解析のような、 パフォーマンスにそこまで影響せずかつライブラリに頼りたい部分はライブラリが豊富な Python で書く案です。　\n\npybind11\n<a href=\"https://github.com/pybind/pybind11\"><img src=\"https://gh-card.dev/repos/pybind/pybind11.svg\"></a> \n\npybind11 は、 C++の関数やクラスをバインドして Python から呼び出すためのライブラリです。\nPyTorch や TensorFlow もこれを使っています。\nかなり少ないコード量でかつオーバーヘッドもかなり少なく Python から C++ を呼び出すことができます。\n\nセットアップ\n環境は以下の通りです。\n\nm1mac なので色々とめんどそうな予感もしますがやっていきます。\nさて、pybind11 は親切にも pip でインストールできます。\n\nバージョンとかにかなりセンシティブなので pipenv とかを使うと良さそうです。\n\n\nこれだけでインストールは完了です。すごい。\n早速 Pythonで動かしたい C++ の関数を書いてみます。\n\nこれを  という名前のモジュールにバインドしてみます。\n\n\nコンパイルしてみます。\n で、pybind11 のインクルードパスが取得できるので、これを渡してやってコンパイルします。\n\nApple Silicon だと  というオプションをつけないとエラーが出るので注意してください。\n\n\n が生成されました。 早速動かしてみます。\n\n\n が計算されてます！ 無事に Python から C++ の関数を呼び出すことができました！　革命ですね \n\n\n\n実践編\nALMO の関数もバインディングすると...\n\n<a href=\"https://asciinema.org/a/659310\" target=\"_blank\"><img src=\"https://asciinema.org/a/659310.svg\" /></a>\n\nPython から  するだけで HTML が生成されるようになりました　🥳\nたいていの型はいい感じに 対応づけられているので、そこまで変なことをしていなければかなり簡単にバインドできると思います。\nまとめ割とお手軽に C++ の関数を Python から呼べました。\n良くも悪くも最近の機械学習のソフトウェアによくある構成なので一応動かし方がわかってﾊｯﾋﾟｰﾊｯﾋﾟｰハッピー\n今日の一曲\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/FEfJB32wvsk?si=JQzQdx6nhqMSXlw8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n",
    "tags": [
      "C++",
      "Python",
      "pybind11",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "mini Kaggle を streamlit で作った",
    "post_date": "2024/05/12",
    "url": "https://abap34.com/posts/dacq.html",
    "thumbnail_url": "https://www.abap34.com/posts/dacq/image.png",
    "content": "\n開発の経緯\n\nギャグの人数がいるサークル用に、昨年から部内コンペ用のプラットフォームを運営しています。\n今は昨年作った Go製のものが稼働しているのですが、いくつかの課題を抱えていました。\n評価指標が全然使えない評価指標の計算まで全て Goで自前で書いたものだったので、新しい評価指標を追加するのが大変です。 Python で書かれたライブラリを使いたいところです。引き継ぎがやばそう今後後輩に引き継いでいくことを考えると、機械学習に興味があってかつ Webができる人に見てもらう必要があります。 流石にまずそうです。\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">新歓が終わって、158人の部員がKaggleコミュニティに入ってくれました🤲´-<br>mlに興味がある人が多くてうれしい<br>運営がんばります‼️ <a href=\"https://twitter.com/hashtag/trap1kaggle?src=hash&amp;ref_src=twsrc%5Etfw\">#trap1kaggle</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1788718306008125491?ref_src=twsrc%5Etfw\">May 9, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nというわけで以前から気になっていた streamlit を使って作り直すことにしました。\n作ったものコンペ機能\nまずメインのコンペの機能ですが、 画面を見てもらうとわかるように\n順位表submitルールの確認スコアの推移の確認チームの作成, 設定\nとかが実装されていて、割とちゃんとしたプラットフォームな建て付けをしています。\n ベストスコアが出るとお祝いしてくれます。\n   \nデザイン力が皆無な自分ですが、streamlit を使うとかなり綺麗なものが出来上がってしまってマジですごい！\nディスカッション機能\nコンペを盛り上げるにはディスカッションが必須です。\nなのでディスカッションのページも作りました。\n\nディスカッションでは、 Jupyter notebook をそのままアップロードすることでディスカッションを作ることができます。\n\n \nJupyter Notebookの実体は jsonで、各セルの属性が書いてあるのでそれを丁寧丁寧丁寧に場合わけすると簡単に streamlit で表示できるようになります。\n実装するとこんな感じです。\n\n便利ですね〜\n開発記録\nこういうのはガッと作るのがいいので、土曜の深夜から作り始めて、一旦寝て日曜に集中して作業して終わらせました。\nwakatime で見てみると大体9時間くらいの作業時間でした。\n\nstreamlit 使ったらすぐ終わるやろ！　という方向性の想定よりは少しかかりましたが、 とはいえこれくらい綺麗な見た目のものがこの短時間でできるのはだいぶ驚きです。\nstreamlit ほんとにすごいと思いました。\n\nYAMLを1時間も触ってる謎の時間がありますが、 mariadb の healthcheck をするときに  で  する方法がなぜか一向にうまくいかずにガチャガチャやっていたせいです。\n\n結局、 mariadb のイメージに最近つくようになった  を使う方法でうまくいきました。\n\n\nそれと、SQL はそんなに得意ではないので消耗しそうだな〜と思っていたのですが、 GitHub Copilot を使ってみると ほとんど一発で所望のクエリを書いてくれてめちゃくちゃ効率がアップしました。\n(一方で streamlit は更新が早いのでろくなコードをサジェストしてくれませんでしたが、まぁしゃーなしですね)\n\n全てを Pythonで書いているのと、大した量のデータを扱っていないので、結構な部分でデータを全て DataFrame にしてしまって、 pandas 芸人力を遺憾無く発揮して手早く実装を済ませました。\n感想\n綺麗な見た目の Webサービスが作れてうれしい 😊\n\nこれでコンペが盛り上がるといいな〜\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mwfgMm2RGNk?si=00Oh44vU7f2shXU2\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "日記",
      "Python",
      "streamlit",
      "Kaggle"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "forkはバッファもコピーするのでフラッシュしておこう ",
    "post_date": "2024/04/23",
    "url": "https://abap34.com/posts/fork_buffer.html",
    "thumbnail_url": "https://abap34.com/posts/fork_buffer/image.png",
    "content": "\nfork関数の挙動\nC言語では  関数を使って  システムコールを呼び出すことができます。\n\n\nこんな感じで親プロセスと子プロセスがそれぞれメッセージを出力してくれます。\n\nところで、  したとき、子プロセスには親プロセスのメモリ空間がまんまコピーされます。\n\n\n\nでは次のコードはどうなるでしょうか\n\nこれの出力はこうなります。\n　が二重に出力されました。\nこれは  したとき、親プロセスのバッファもコピーされるためです。\n する前にはちゃんと  しておきましょう。\n感想\nシステムプログラミングの講義で先生が話していて試したら確かにそうなってへ〜〜ってなりました\n\n",
    "tags": [
      "Unix",
      "OS",
      "C"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "rebaseしてもGitHub上でのコミット時刻を保つ",
    "post_date": "2024/04/13",
    "url": "https://abap34.com/posts/git_date.html",
    "thumbnail_url": "https://abap34.com/posts/git_date/image.png",
    "content": "イントロ\n を使うと昔のコミットを編集することができます。\n\n昔のコミットに Co-Author を追加したくなり rebase した後に、コミット時刻が  で見ているときと GitHub で違うことに気がつき、いろいろ調べてみたのでまとめます。\n\nGit の二つの Date\nGit でコミットするとコミット時刻を記録してくれますが、実は二つの時刻があります。\n実例で見てみます。\n\n\nとりあえず  というファイルを作成して  しました。\nこのコミットの時刻を調べてみます。　\n( に ハイライトが当たらなくて死ぬほど見にくいので、スクショにします)\n\nコミットした時刻の  が記録されています。  これを push して GitHub 上で見ても当然この時刻が表示されます。\n\nところが、  でくわしく見てみると、\n\nさっきまで一個しかなかった Date が  と  の二つになっています。\n\nもう一個コミットを積んでみます。\n\n\nおやつを食べてたら 16:13 でした。\nこの場合も同様に、 と  として同じ時刻が記録されています。\nここで、 最後のコミットメッセージを変更してみます。\n\nさっきのコミットメッセージを  に変更しました。\nこのコミットの時刻を見てると、編集前のコミット時刻である  が記録されていますが、  で見てみると、\n\n\n\nこんな感じで、  にはコミット時刻が、  には  した時刻が記録されていることがわかります。\n\nこれを GitHub で見てみるとどうなるでしょうか。\n\n\n\n\nと、こういう感じで  が表示されます。つまり、\nコミットが作られた時刻 で表示されるコミットが最後に編集された時刻GitHub で表示される\nです。なんで  と GitHub で揃ってないんでしょうか。\n\nAuthorDate と CommitDate を揃える\nさて、二つの時刻があるのはいいとして、これで困ることもあります。\n\n最初にも書いたのですが、昔ペアプロで作ったコミットを自分名義だけでコミットしてしまったので、 今更ながら Co-Author を追加したくなりました。\n\nCo-Authorの追加 は Gitの機能ではなく GitHub の機能ですが、要はコミットメッセージに  を追加するという作業です。\n\nなので昔のコミットまで戻ってコミットメッセージを修正すればいいのですが、ここまでで分かるように普通に rebase してしまうと  が変わってしまい、GitHub で表示される時刻が変わってしまいます。\n\n は残ってますが、 GitHub上でコミット履歴を見たときに全部 rebase したときの時刻になっているのはちょっと嫌です。\n\nそんな困った人のために実は rebase にオプションが用意されています。\n\n説明のために何個かコミットを積みます。\n\n今はこんな感じです。\n\n\n三番目のコミットを同じように編集します。\n\nこれをすると先ほど見たように  が変わってしまいます。\n\n\nここから  を揃えましょう。\n\n先ほどと同じところまで rebaseするときに、  オプションをつけます。\n\n\n\nすると、三番目のコミットの  が  と同じになりました！\nこれで GitHub上でも履歴を保ったまま Co-Author を追加することができました。\n\nまとめコミットには時刻が二つ記録されてるよところによって表示されるものが違うので気をつけようrebase するときに  オプションをつけると  を  に揃えることができて便利\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fGx6K90TmCI?si=7QNwsgeLoPxrsEo_\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "Git",
      "GitHub"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "livereload でホットリロードするCLIツールを作る",
    "post_date": "2024/04/09",
    "url": "https://abap34.com/posts/livereload.html",
    "thumbnail_url": "https://abap34.com/posts/livereload/thumb.png",
    "content": "\nlivereload\n は Pythonのパッケージで、ファイルの変更イベントを検知していろいろ走らせることができます。\n\nなのでコレをつかって  でリアルタイムにプレビューできる CLI ツールを作ります。\n実装\n\n\n\n を適当に書いて、コマンド一個で叩けるようにしておきます。\n\n\n\n\n結果\n\n\nいい感じにプレビューできるようになりました！ \n\nもうすでに VSCode拡張で同じ機能が実現されていましたが、 ブラウザと微妙に表示が違ったり  は別ウィンドウで開けなかったりと色々と不満があったので、 ブラウザで見ることができるのはかなり便利です。\n\n今日の一曲\nCool\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/XEKPn3WbksE?si=ac7SmasFiL-TYLkM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n",
    "tags": [
      "Python",
      "Web",
      "CLI"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "GitHub Actionsでリリース時に自動ビルド + Docker Hubにイメージアップロード + GitHub Actionsから利用",
    "post_date": "2024/04/02",
    "url": "https://abap34.com/posts/almo_autorelease.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/basenji/n02110806_4199.jpg",
    "content": "\nいろいろ大変リリース作業\n拡張 Markdownパーサ兼静的サイトジェネレータの   を毎日たのしく開発しています。\nところで、これは静的サイトジェネレータなので、いろんな人のブログなどに使ってもらうことを想定しています。\n\nとなると、 GitHub Actions などでも利用しやすいように環境を整える必要があります。\nGitHub Actions では、  のように指定することで Docker Hub にあるイメージを利用することができます。\n\nそこで、リリースを打つたびに Docker イメージをビルドして、 Docker Hub にアップロードするようにします。作業記録です。\nDocker Hub にイメージをアップロードする\nとりあえず Dockerfile を作ります。\n\n で My Account > Security > New Access Token からトークンを取得します。\n次にレポジトリの Settings > Security > Secrets and variables > New Repository Secret から  と  を設定します。\n\nあとは以下のように GitHub Actions を設定します。\n\n\n注意ポイントとしては、 GitHub Actions からこのイメージを利用するときは  などが上書きされるみたいなので気をつけて  と  を作らないとハマります。\n\n\nこれで、リリース時に Docker イメージをビルドして Docker Hub にアップロードすることができるようになりました。\n\nリリース時にいろんなプラットフォームに対応する\nコレは、 GitHub Actions でマトリクスビルドを使うことで簡単に実現できます。\n\n\n便利ですね。\n\n使用例\nDocker Hubにアップロードしたおかげで 誰でも簡単にビルドができるようになりました。\n\nして、\n\nするだけで利用できます。　便利！\n\nGitHub Actions からも\n\nだけで利用できます。\nおわりに\n終わりです。\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/EJ8lBjQls4w?si=PdBx5TBPvW-z3_ZG\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "Docker",
      "Docker Hub",
      "GitHub Actions",
      "CI/CD",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "2023年度後期振り返り",
    "post_date": "2024/03/29",
    "url": "https://abap34.com/posts/hurikaeri_2023_1.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/spitz-japanese/tofu.jpg",
    "content": "\n2023年度後期の振り返り\n2023年度・学部2年生もほぼ終わりました。\nとりあえず後期(10月~3月)の振り返りです。\n前期の振り返りは　\nJuliaTokyo11\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">今日の JuliaTokyo でのトーク、「Juliaで歩く自動微分」のスライドをアップしました！ <br>- DLフレームワークの中身が気になる方<br>- 何もかも勾配降下法で最適化したい方<br>- 低レイヤと機械学習の絡みが気になる方<br>はぜひ！！<a href=\"https://twitter.com/hashtag/juliatokyo?src=hash&amp;ref_src=twsrc%5Etfw\">#juliatokyo</a><a href=\"https://t.co/XZ8ovEJvvs\">https://t.co/XZ8ovEJvvs</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1753681336702009787?ref_src=twsrc%5Etfw\">February 3, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nまずは JuliaTokyo #11 です。 30分トーク枠で自動微分について話しました。\nいろんな方に反応貰えてれしかったですが、 とくに Juliaコンパイラの中の人の  さんに懇親会とその後 Twitterで褒めてもらえたのが嬉しかったです。\n\nJuilaの対面のイベントに参加するのは5年前、高校1年生の時のJuliaTokai以来でしたが 懇親会でいろんな人に再会でき、海外の人とも話せて楽しかったです。(英語力の無さも痛感...)\n\n最近は Juliaの日本語コミュニティが Discordで発足して割と動いていたり、コミュニティが活性化していてなんかいい感じです。\n自分も Juliaのコミュニティに育てられたので、色々と還元できるように頑張ります。\natmaCup #16\n に参加しました。\n宿のレコメンドというタスクでしたが、ユーザの行動履歴が短く、めちゃくちゃむずかしかったです。\n学生枠でなんとか入賞して表彰式に参加させていただいたんですが、懇親会とその後の飲み会でいろいろな人と話せて楽しかったです。\n\nALMO\n結構ALMOの開発は進んでいます。このブログを動かしてるので、欲しい機能を追加し続けていく過程で色々やっていたみたいです。\nリリースは 20回を超えて v0.7.0 まできました。  \n\nエコシステムも色々整備してます。例えば   は VSCode でプレビューしてくれるやつです。便利。\n他にも  とかもあります。 ぽちぽちでブログが作れるやつです。\n\n\nabap34.com\nこのサイト自体がずいぶんアップデートされて綺麗になりました。\nブログだけでも\n記事の検索機能タグ機能コメント機能RSS\nなどなどついて結構いい感じです。\n\nMinia.jl\nJuliaで書いた処理系です。\nPEGで構文を書いて、JuiaのASTに変換して実行するみたいなやつです。 \n\n<a href=\"https://github.com/abap34/Minia.jl\"><img src=\"https://gh-card.dev/repos/abap34/Minia.jl.svg\"></a>\n\nどちらかというと、付随して書いた  の評判が良かったです。\nTinyPEG.jl\nMiniaのパーサは PEG.jl という既存のパーサジェネレータを使っているのですが、せっかくなので PEGパーサジェネレータを作りました。\n<a href=\"https://github.com/abap34/TinyPEG.jl\"><img src=\"https://gh-card.dev/repos/abap34/TinyPEG.jl.svg\"></a>\nこれもブログ  にしました。\n\nage++\nついに 20歳になりました。\n\nいろんな人に祝ってもらいました。マジで恵まれてるなぁと言う感じです。\n周りの全部の人に感謝してます。\n\nぜひ🍺誘ってください。\n\nその他・大学など2回目の作問ハッカソンで作問をしました。 一回目は  を出したので、今回は  になりました。最近スライドを作る機会が多かったので、いい感じのテンプレを作ったら QoL があがりました。 <a href=\"https://github.com/abap34/slide-template\"><img src=\"https://gh-card.dev/repos/abap34/slide-template.svg\"></a>大学では、ドイツ語のやる気が出ないことが確実視されたので、履修登録から抹消して代わりに3年次の文系教養の履修を済ませました。これで3年次はドイツ語にさえ集中すればいいわけですが、一年間やる気が出なかった科目に来年度やる気が出るかは不明です。全国医療AIコンテストに参加しました...とは言っても参加した頃には LBでかなり差が開いていて意気消沈状態でした。1subだけして撤退してしまったのですが、セグメンテーションのコンペはやったことなかったのと、monaiは初めて使ったのでこれに詳しくなれたのはとてもよかったです。コンペをやっていていい感じに NIfTIをプレビューするツールがなかったので試作したりしました。 速度をマシにしたら公開します。<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">医療AIコンやってて、NIfTI 画像をコマンドライン一発でプレビューできるツールでいい感じのがなかったのが不満でチャッと実装してみた<br>sixel と格闘してたものの全然うまくいかなかったので一旦 GUI版で... 便利！<br>(実際はロード時間が結構かかっているのでいい感じに爆速にして公開したい) <a href=\"https://t.co/Z6pqseeCll\">pic.twitter.com/Z6pqseeCll</a></p>&mdash; abap34 (@abap34) <a href=\"https://twitter.com/abap34/status/1771371540514247088?ref_src=twsrc%5Etfw\">March 23, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>大学で所属しているサークルで「Kaggle班」を立ち上げました。昨年度も色々やってきましたが、今年も面白いことができるよう運営を頑張ります。\n2024年度の抱負\nついに学部3年生になります。\n学部生も折り返しですが、一応卒業要件的なのは大丈夫そうでホッとしています。\n\n目標は色々ありますが、\nKaggle班運営を軌道に乗せるOSS Contribution を積極的にやる\nあたりはやりたいところです。\nあとはいろんなコミュニティで色々な人と交流したいです。\n技術面での目標ですが、 特に最近、コンピュータサイエンスがみんな面白くて、多分来年も同じ調子だと思うので、 そのとき興味あることをちゃんとできればと思います。\n\nとにかくプレイヤーでいたいです。\n頑張ります。\n\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7xx66mR_HeE?si=U0YEvzeB4kqud4OK\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n",
    "tags": [
      "日記",
      "振り返り"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "Marp + GitHub Actionsのテンプレートを作った",
    "post_date": "2024/03/14",
    "url": "https://abap34.com/posts/slide-template.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/boxer/n02108089_2653.jpg",
    "content": "\n\nMarp + GitHub Actionsのテンプレートを作った\nタイトルの通りです。\nレポジトリは、\n\n<a href=\"https://github.com/abap34/slide-template\"><img src=\"https://gh-card.dev/repos/abap34/slide-template.svg\"></a>\n\n\n内容としくみ\n内容\nこのテンプレートを使うと、\nMarp でスライドを書いて、 main に push すると自動でビルド & GitHub Pages にデプロイスライドのソースファイル分割\nができます。\nスライドが共有しやすくなりますし、 Git管理の設定の手間が省けます。\n\nまた、 ファイルが長大になるとdiffがわかりづらくなる、VSCode extensionで表示がチラつくなどの現象がよく発生してましたが、 ファイル分割することで、これらの問題も解消されます。\nしくみ\nGiHub Actions\n\n\nここは特に何もしてなく、普通に Marp のビルドを行って、 GitHub Pages にデプロイしています。\nMarpは公式でDockerイメージを提供しているので、それを使っています。\n\nMakefile\n\n\n\n本質パートはここです。\n\nMarpでは YAML Front Matter で設定を行うことができます.\nこれがないと VSCode でプレビューができないので、それぞれのファイルで先頭にこれを書く必要がありますが、 結合するときに不都合です。\n\nなのでちゃっと  で二つ目の  までを削除することでいい感じに結合できます。\n今日の一曲\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ayDVB4IAZWA?si=NrdiIKGNQkvdetr8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n",
    "tags": [
      "日記",
      "Marp",
      "GitHub Actions"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "(WIP) 【週刊 PEGパーサジェネレータ を作ろう】 [創刊号] [最終号]",
    "post_date": "2024/03/06",
    "url": "https://abap34.com/posts/tinypeg.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/bluetick/n02088632_419.jpg",
    "content": "\n\n創刊\nこの前こんな記事を書きました。 \n\nこの記事では Julia製の PEGパーサジェネレータ  を使ってパーサを作りましたが、せっかくPEGを勉強したので自分でも作ってみようと思います。\n\nいろいろな言語の解析の計算量\nPEG自体は上について説明を書きましたが、パーサジェネレータを作るからには吐かれるパーサのパフォーマンスも気になります。\nそこで一旦、 いろんな文法で定義された構文の解析の計算量の話をしようと思います。\n1. バックトラックなしの正規言語(表現) の解析 (DFA型の正規表現エンジン)\n形式言語の講義で習うような、定義通りの正規言語( 正規表現で表現された) 言語  について考えてみると、 入力文字列  の長さを  として　毎回  時間’で   かを判定できます。\n\nというのも、全ての正規言語に対して対応するDFAが存在するので、これをあらかじめ作っておけば、  ステップで受理できるか判定できるからです。\n\n実用的には、 は正規表現で書かれることが多いでしょうから、DFAの構築自体も考えなければいけません。\n\n正規表現をNFAに変換するのは正規表現の長さに対して時間・空間ともに線形でできます。\nDFAにNFAを変換する際はナイーブにやると状態が正規表現の長さに対して指数オーダーになってしまいますが、 遅延評価で必要な状態だけを作ることで正規表現の長さに対して線形時間・空間 + 入力文字列の長さに対しても線形時間・空間で出来ます。\n\ngrepや などはこうして実装されています。\n\nというわけで安心─というわけにもいきません。\n2. バックトラックありの正規言語の解析 (VM型の正規表現エンジン)\n世の中で「正規表現」という顔をして提供されている  みたいな名前のパッケージたちは 形式言語理論の正規言語の範囲を逸脱した機能が提供されていることが多いです。\n\n例えば後方参照などは正規文法では表現できません。 Perl が これらの「拡張」正規表現を採用し、 PCREとして広く普及してしまったためにこのような拡張が一般化してしまいました。 (ただ、最初に導入したのは SNOBOL という言語らしいです。)\n\nでは、このような「拡張」正規表現によって表現される言語の解析はどれくらい難しいでしょうか？\n\nバックトラックが...とか書こうと思ったのですが、そのような記事は結構ある(\"ReDoS\" とかで検索すると出てくる)ので、\nここではちょっと面白い結果でおそらく線形時間ではできないだろう、もっと進んで多項式時間まで緩めても できないだろうということを主張したいと思います。\n\n によれば、 Perlの正規表現エンジンは、3SATを解くことが出来ます。 \n3SAT は NP困難な問題なので、もしこの正規表現が多項式時間で解析できたら  無事に P=NP となります。　\n\nなので、少なくとも Perlの正規表現を常識的な (?) 多項式時間で解析するアルゴリズムにお目にかかれる日が来るかは怪しいところです。\n(常識的でなくてもお目にかかれたらすごいですが)\n\n3. 文脈自由言語の解析\n有名なものとして、CYKアルゴリズムがあります。\n\nこれは DPを使って 時間計算量  で動作するアルゴリズムです。\nまた、 Earleyアルゴリズムという改良もあります。曖昧でない文脈自由言語に対しては  で、 一般の文脈自由言語に対しても  で解析できます。\n\nとはいえこれでもあまり実用的なパフォーマンスが出にくく、 任意の文脈自由言語に対して高速になるようアルゴリズムを改良するのではなく、\n解析しやすい性質のいい言語を考える方向性で頑張るという方向性に進んでいったようです。\n\nこの辺の流れは全然体験しておらず、読んだ文章を鵜呑みにしています。歴史とかいずれ調べてみたいです。\n\nそのため、多くのプログラミング言語などは LALR(1) などで解析できるものになっています。\n(ということになっていますが実際はあれやこれやと補っていることも多いようです。 例えば C は  構文の存在によって文脈依存言語になっています。)\nPEG と Packrat ParsingPEG vs CFG\nさて、となると気になるのは PEGです。\n直感的には、文法の表現能力が高いほど解析も難しくなるのではないかという気になるので、PEGの表現能力について考えてみます。\nまず、有名な話として  は正規言語ではありません。\nさらに、　 まで行くと文脈自由言語でもありません。\nそこでこれを PEG で表現できるかを考えてみると、PEG では以下のようにすると  が表現できます。\n\n逆に文脈自由文法では表現できるが、PEGでは表現できないという言語が存在するかは未解決のようです。\n\nまとめると、PEG は少なくとも文脈自由言語と同等あるいはそれ以上の表現能力を持っていると言えます。\nしたがって、直感的には PEGで書かれた言語の解析は難しそうな気がします。\n(wip) PEG の解析\n\nまず、ナイーブにやると最悪計算量は普通に  になります。\nPEGは順序付き選択をサポートしているので、ここでバックトラックが発生してしまうためです。\nしかし、 解析を進める際に、その時見ている非終端記号と位置をキーにして結果をメモ化しておくだけで、 なんと一挙に  が保証されます。\nこれが Packrat Parsing と呼ばれる手法です。\nPackrat Parsingは本当に効率的？\nさて、かなり劇的な性能改善が起きていて採用待ったなしのように見える Packrat Parsing ですが、 実際これがどれくらい実際のパフォーマンスに影響するかを考えてみます。\n\n驚くべきことに、「ふつうの」解析の場面では Packrat Parsing はあまり効果を発揮しない という意見がかなり多いようです。\n\nまず、一般的に非終端記号の使われる頻度はかなり偏っています。\nプログラミング言語なら  などはしょっちゅう使われると思いますが、 例えば  などはほとんど使われないと思います。\n\nさらに、世の中で使われている多くの文法は LALR(1) などで解析できるものでした。\nたとえ PEG を前提に文法を組み立てても、これらに近い見た目のものを自然と作ることで、 結果的にバックトラックが結果としてあまり発生しない文法になリます。\n\nこれらの理由から、何でもメモ化するとオーバーヘッドが大きくなってかえって非効率になることが多いようです。\n\nしたがって、設計者が指定する、あるいは実際に参照される頻度に基づいて特定の数個の非終端記号に対してのみメモ化を行う というのがよく取られる戦略です。\n\n(todo: この辺りを実測した結果を載せる)\n\n\n(WIP) PEGパーサジェネレータを作る。 \nさて、 本題です。 まずは一旦計算量とかの話は忘れて、素直に意味論に従って PEGパーサジェネレータを作ってみたいと思います。\nデザインサポートする構文\n次の構文をサポートすることにします。\n文字列()正規表現 ()連接()選言()否定先読み()任意文字()0回以上繰り返し()\n や  は PEG自体には本来ないですが、 記法として便利なので追加します。\n を正規言語の範囲内で使えば、これによって表現能力が変わることはありません。\n実装\n実装していきます。　\nまずはパースコンテクストを定義します。\n\nここで、文字列のスライスは allocation が発生するので、これを避けるために  を使います。\n\nので、パースコンテクストは入力文字列だけ持って、  を返すようにしておきます。\n\n とかはもちろん  なら使えるので、これで色々実装していきます。\n例えば  :\n\n:\n\n完成したものがこちらになります。\n\n<a href=\"https://github.com/abap34/TinyPEG.jl\"><img src=\"https://gh-card.dev/repos/abap34/TinyPEG.jl.svg\"></a>\n\n廃刊\nおもしろいです！\n\n  とか、 あるいはもっと実践的な(?) コンパイラとかで使われる話が乗ってる本を読んでみたいなと思いました。\n\n今日の一曲\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/yVWCezwyEsM?si=Tx-kE-6UpcvlPFYb\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n\n\n",
    "tags": [
      "Julia",
      "PEG",
      "パーサ"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "3時間で作る自作言語のJuliaトランスパイラ",
    "post_date": "2024/02/22",
    "url": "https://abap34.com/posts/mini-lang.html",
    "thumbnail_url": "https://abap34.com/posts/mini-lang/image.png",
    "content": "\nAbstract\nJulia で簡単な処理系を作りますPEG.jl を使うと簡単に厳密な構文を定義・解析できます入力をJuliaのASTに変換して実行する方式だと簡単にできて便利で楽しいです\nはじめに\nI県の国立T大学の講義では、簡易インタプリタを作る課題が出るらしいです。\nまた、言語が指定されていないようで色々な言語での実装を GitHubで見かけて、  なんかもあったりしていいなぁと思ったので Juliaでも作ってみました。\n\nというか  がイケてるエンジニアの人呼んで面白そうな話が並んでいて羨ましいです。 T工業大学でも同じようなテイスト(卒業生が来る系)の講義があったような気がしますが、卒業生でえんえんビジネス人生を語る皆様がたくさんいらっしゃるのでそういう話に興味がある人が受講するといいかもしれません。\n\nそれはそれとして、いろんな言語で実装されてるなら自分もなんかでやりたくなってくるところです。\n今までの自分の構文解析遍歴は、\n講義(形式言語とオートマトン) で理論かじったり自作の拡張 Markdownパーサの  とか 大学のアセンブリ言語の課題で数式をパースしてみたり \nみたいな感じなのですが、 C/C++ でしかやったことがありません。 C++ はまだしも Cは全然自分の手足感がないので、慣れている Python / Julia あたりでやりたいと思っていて、 さっきの gist をみていると Python実装はもう結構あるみたいなので Juliaでやってみることにします。\n\nそれに加えて、自分で素のパーサを書くのは Markdownパーサを書いたときに、もうこりごりだ〜〜(本当に)と思ったので、今回はパーサジェネレータを使っていい感じにやることに決めました。 (Markdown の仕様によるところもある気がしますが...)\nPEG.jl で構文を書くPEG とは\nさて、プログラミング言語を作るからにはパーサを作らなくてはいけないですが、今回は\n\n<a href=\"https://github.com/wdebeaum/PEG.jl\"><img src=\"https://gh-card.dev/repos/wdebeaum/PEG.jl.svg?fullname=\"></a>\n\nを使います。\nそもそも PEGという耳馴染みのない(僕はありませんでした)という単語について説明しておきます。\nPEGは Parsing Expression Grammar の略で、日本語だと解析表現文法とか言われるものです。 \n\nその名の通り文法なのですが、多くのプログラミング言語の構文の記述に使われる  文脈自由文法とは違い、 構文木が常に一意に定まるという特徴があります。\n\nさらに、PEGは文脈自由文法ではできない  を受理する構文を定義することができ、 また 「PEGで記述不可能だが文脈自由文法で記述可能な構文」 は今のところ見つかっていないので、 PEGは文脈自由文法よりも表現力のある文法だと考えられているようです。\n\nPEGは、技術としては思ったよりだいぶ最近のもので、なんと提案されたのは 2004年です。  大学の講義でも多分扱っていなかったと思うのですが(先生へ: 扱ってたらすいません)、たまたま大学図書館で   という本を見つけて読んでへ〜となったので使ってみることにしました。\n(この本では構文解析自体の説明から平易に書かれていて実装もPythonで読みやすく、おすすめです。最後の方の章の計算量とかのところでこれは大丈夫か...? と思うところもありますが、全体としては実践的で好きです。)\nしかも、Python 3.9からはPythonのパーサがPEGベースになり、JuliaのパーサもScheme製だったのが Julia製になって Syntax Error がだいぶ見やすくなったりと、 世はまさに大パーサ改善時代と言えそうです。\n\n構文解析がそこまで最近に進化しているのは正直イメージと違ったのでびっくりしました。　もっと早く知ってたらもう少しオートマトンにやる気が出たかもしれない...\nPEG の特徴と PEG.jl を使った実践\nPEG.jl はそんな PEGを使って構文を定義・解析してくれるライブラリです。 最終更新はとても前ですが、READMEに書いてある通り機能がすでに十分に揃っているので特に困るポイントはありません。\nさて、PEG.jl を使って構文を定義してみます。 見た目は拡張BNF記法そっくりで、直感的に書けるのでとても使いやすいです。\n例えば、一桁の数字同士の足し算を定義するとこんな感じになります。\n\nこのように、\n マクロでルールを定義 でパース\nという 2ステップで簡単に構文を定義・解析できます。\nさらに、  ではパース結果を渡す関数も同時に定義できます。\n例えば、 文字列  を   で整数に変換して、計算式をその場で評価してみます。\n\n足し算のパース・解釈ができるようになりました。\n\n\nここまでだとあまりBNFと変わらないように見えますが、違うポイントを見てみます。\nといっても違うポイントは一つだけで、選言() と順序付き選言() です。\n例えば BNF記法で\n\nと書いた場合、  は  または  どちらにマッチしてもかまいません。\n\nこれにたいして PEG では順序付きの選言を使います。\n\nと書いたとき、  は  にマッチするか試し、成功したら  にマッチし、そして失敗したその時に限り  にマッチを試みます。\nしたがって結果は必ず一意に定まります。\n\nさらに、これは選言がプログラムでの  に対応してほしいという気持ちになると割と自然です。 ふつうの処理系では  という式の  は短絡評価で  が　 だったその時に限り評価されるわけですから、 どちらかというと順序付きの選言の方が  に近い感じがします。\nJulia の ASTへの変換\n上の例ではパースしたものをその場で解釈していましたが、これだと評価を自分で書く必要があってめんどくさいため、誰かに実行をやってほしくなります。\n…よくよく考えてみるとパースを動かしている処理系、Juliaがすでに手元にあるわけですから、なんならパースだけでなく実行もやってほしいような気がします。\n\nつまりは、Juliaへのトランスパイラが書きたくなってきます。\n\n大変な仕事に見える人もいるかもしれませんが、実はこれは本当に簡単な作業です。\n\nJulia はそれ自身の構文を普通のデータとして扱うことができます。 これは同図像性(Homoiconicity)などと呼ばれる性質で、同様の性質を持つ言語として、代表的なものに Lisp があります。\nLisp の構文はただの(?) リストなので、 Lisp のコードの表現は Lisp の基本的なデータ構造に過ぎません。\n\nJulia においては、  型によってその構文を表現できます。実例で見てみます。 \n(出力は一部省略しています)\n\n で囲むと中の式を評価せずに、その式自体の構造、つまりはASTを得ることができます。 これは  でわかるように  型で保持されていて、  で中身を見ると、確かに元の式の構造っぽいものが保存されているようです。\nあるいは、 S式の形で出力することもできます。\n\nそしてこのASTを作る手段は当然開かれています。\n例えば、  を計算して出力するようなASTを、「手で」作ってみることにします\n\n\nこんな感じで、 ASTを直接作って、  に相当するコードを表現・実行することができました。\n( によって、式の結果ではなく式そのものが保持されていることがわかることに注目してください！)\nこれで、最初の例の足し算のパーサを書き換えて、ASTを作るようにすれば、自動的にJuliaのコードに変換できるようになります。\n\n という単なる文字列から  を表現する Juliaの AST を得ることができました。 つまり、\n🎉 まさに今、自作言語をJuliaにトランスパイルするプログラムが動きました。 🎉\nもはやあとは作業ゲーで、これを気合いで拡張していけば完成です。\nひとまず、どんな言語にするか考えてみることにします。\n\n言語の設計イメージ\nさて、本格的に言語を作り始めます。\nだいたい、次の要素を含むプログラミング言語を作ることにします\n基本的な二項演算(四則演算, 剰余, べき乗, 比較演算)変数関数定義 / 呼び出し / ブロック, 整数, 浮動小数点数, 文字列　あたりのリテラル\nこれだけあれば十分実用的な感じの言語な感じがします。 構文は、元の実装を参考にしてよくある感じの波括弧を使うものにすると、だいたいイメージとしては以下のように  FizzBuzz が書ける言語を作るのが目標になります。　結構見た目は立派な言語ですね。\n\n\nPEG.jl による記述\nあとは対応を考えてえいやえいやと文法を定義します、\n例えば自然数リテラルはこんな感じになります。\n\n定義したら REPL に送って試してみます。\n\nいい感じですね。リテラルはJuliaのASTでもそのまま表現は変わりませんから、普通に  で  に変換してしまいます。 \nこんな感じの再帰的に  を flatten して結合してくれるやつを用意しておくと便利です。\n\n浮動小数点数リテラルも同様に定義します。\n\nこれで数字リテラルが使えるようになりました。 表記に応じて適切なパースができています。\n\n\nさて、今回は浮動小数点数の左右(?)の省略は許さないことにしたので  がエラーになるのは意図した挙動ですが、 どうしてもこういう場合意図した挙動にできてるかを見逃してしまいがちです。\n\nなので、構文を定義して動かす前に必ずテストケースを十分用意しておきましょう。\nテストケース作る  構文一個作る  テストケース通る  次の構文一個作る  のループを踏まなかった人には等しく死が訪れます。\n例えばこんな感じの実装の仕方がありそうです。\n\n は  と等しいか判定する関数を返してくれます.  値を直接書いて比較するより、この形で書いておくとエラーさえ起きなければいい、とか割と自由にテストを書けるので便利です。\n正直これ以上はもはや書くことがあんまりなく、\n で構文を定義REPL に送ってパースしてみて吐かれる解析結果を見るそれの対応を見て、 AST を作る\nというのを繰り返していけば良いです。\n完成したものがこちらになります。　実装に詰まったら見てみてください。\n\n<a href=\"https://github.com/abap34/Minia.jl\"><img src=\"https://gh-card.dev/repos/abap34/Minia.jl.svg?fullname=\"></a>\n\n感想\nもし自分が生まれるのが10年, 20年早かったら Lispとかどハマりしてそうだな〜　とおもいました\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/u5KV0B0teIA?si=BExLRLOYtO5nDJZj\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n\n\n 文脈自由文法の日本語のWikipediaに残ってるレスバの痕跡が好きです。 　\n\n\n\n",
    "tags": [
      "日記",
      "Julia",
      "コンパイラ"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "作問ハッカソン 002で作問しました ",
    "post_date": "2024/02/17",
    "url": "https://abap34.com/posts/sakumon2.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/rottweiler/n02106550_3528.jpg",
    "content": "\nDon't cut line!\n\n が運営してくれている traPのアルゴ班作問部で2回目の作問ハッカソンが開催されました。\n\n実は一回目も参加していて、こんな問題:  を作ったのですが、 今回も参加して問題を出しました！ \n  \n\n\n題材としては、最近クラスカル法やプリム法の最適性の証明とかを勉強したので、このあたりに着想を得て作りました。\n実は、元の問題は  と定義されていたのですが、これのいい感じの解法がわからなかったので  として出題しました。(調査の結果、元のやつは NP-hard で、色々となんか手法の提案はみたのですがいまいちわからずでした.)\n\n\n感想としては、テストケースを作るのがとても難しかったです.\n問題の性質上、  番目の(?) 最小全域木からがコストの制約を満たす...みたいな感じにしなくてはいけない上、 そもそも入力は連結で単純にしないといけないので、脳死でランダムに作るみたいなことは当然ダメで、解法からいい感じに逆算して作る必要があったので色々と勉強になりました。\nコンテスト中の提出を見ていると、この辺頑張って作ったテストケースがかなり撃墜してくれていたのでとてもよかったです。\n\n前回のコンテストではかなり後ろの方の問題だったのでそこまで大量の提出が飛んでこなくて暇だな〜と思っていたのですが、 今回は70以上の提出があり、30人以上の方に解いていただけてとても嬉しかったです、ぜひ解いてみてください！\nまた、解説を頑張って書いたのでここにも掲載しておきます。\n\n<details style=\"border: 1px solid #ccc; border-radius: 4px; padding: 10px;\"> <summary>解説(ネタバレ注意)</summary>\n は、 に含まれる最も  の大きい辺の  のみによって決まります。\nそのため、 条件を満たすように を最大化するには、なるべく大きい  を持つ辺を一つ採用し、あとはコストが最も小さくなるような全域木を作れば良いです。\nつまり、\n<ol>     <li>利益の大きい順に辺を選び、これを含むようなコストの最も小さい全域木  を求める　</li>         <ul>             <li>                  なら選んだ辺の利益を出力して終了             </li>             <li>                 満たさないなら次に大きい辺を選ぶ             </li>         </ul>     <li>         最後まで満たさなかったら  を出力して終了     </li> </ol>\nという方法で今回の問題を解くことができます。\nこれを行う最も素直な方法は、辺を一つ選んだのちに、その辺が結ぶ二つの頂点をまとめて新しく得たグラフの最小全域木を得て、条件を満たすか確認することです。\nしかし、最小全域木を作る際には  本の辺を選ぶ必要があるので、 毎回  の計算量がかかってしまいます。\nそして、あらかじめ選ぶ辺の候補は  本あるので、今回の制約でこのアルゴリズムを時間内に実行することは難しいです。\nそこで、これを高速化することを考えます。\n\n実は、毎回最小全域木を求め直すのではなく、与えられたグラフ  に対する最小全域木をあらかじめ求めておくと、\nある辺が含まれるような全域木の最小コストを高速に求めることができます。\n\n\n の最小全域木  をあらかじめ求めたとします。\nこれに操作を加えることで、辺  が含まれるような全域木のうち最もコストが小さくなるようなものを得たいです。\nまず、 を  に加えると、  にあらたに閉路がただひとつできます。\nしたがって、この閉路の辺をどれかひとつ削除すれば全域木となります。\nそしてこのとき、この閉路の辺のうち  以外で最もコストの大きい辺を削除することで  を含む最もコストの小さい全域木を得ることができます。\nこれは、あらかじめ  を採用した状態でクラスカル法を適用することを考えればわかります。\nこの閉路を構成する辺のうち、最後に選ばれる辺である最もコストの大きい辺を追加すると、  がすでにあることから閉路ができるため、採用されなくなるためです。\n\n\nしたがって、  が含まれる最もコストの小さい全域木は、\n\n木  があったとき、\n\n<strong>「  に 辺  を追加したとき、できる閉路の辺のうち  以外で最もコストが高いものはいくつか？」</strong>\n\nというクエリに高速で答えられるようになれば、高速に求まることになります。\nここからは、これについて考えます。\n\n<h3>削除する辺の高速な求め方</h3>\nここで、できる閉路は、  の最小共通祖先を  としたときに\n「 から  を繋ぐ経路と  から  を繋ぐ経路という二つの経路が合わさったものである」ということに注目します。\nすると、 を繋いだことでできる閉路の辺のコストの最大値は、\n「 から  への経路の最大値」 と 「 から  への経路の最大値」 の大きい方になります。\n\nつまり、先ほどのクエリは 「 の  の最小共通祖先までの経路上のうち最もコストが高いものはいくつか？」\nと言い換えられ、これにはダブリングと呼ばれるテクニックを用いると高速に答えることができます。\n\n\n\nダブリングを用いると、頂点数  の木の二つの頂点  の最小共通祖先は  で求めることができます。\n\n\nさらに、これを求める際に、各頂点からの親への遷移の情報と共に、親への遷移の経路上の辺のコストの最大値を管理することで、\n\n\n それぞれからの最小共通祖先への経路上の最大コストを同時に求められます。\n\nしたがって、この方法で  の時間計算量で目的の辺を特定することができます。\n\n<h3>最終的なアルゴリズム</h3>\nここまでの議論から、最初に登場した\n<ol>     <li>利益の大きい順に辺を選び、これを含むようなコストの最も小さい全域木  を求める　</li>         <ul>             <li>                  なら選んだ辺の利益を出力して終了             </li>             <li>                 満たさないなら次に大きい辺を選ぶ             </li>         </ul>     <li>         最後まで満たさなかったら  を出力して終了     </li> </ol>\nという方法は、\nクラスカル法などで、 の時間計算量であらかじめ  の最小全域木  を求めておくことで、\n\n\\1. の時間計算量が 毎回 となり、\n試す辺の数は高々  本なので、全体としては  の時間計算量となります。\n今回の問題では、このアルゴリズムを時間制限に十分間に合うように動作させることが可能です。\n</details>\n\nまた、準備でいろいろと　 と  くんにめちゃくちゃ助けてもらいました、 大変ありがとうございました(土下座)　🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️🙇‍♂️ \n",
    "tags": [
      "競プロ",
      "traP",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "JuliaTokyo #11 でトークをしてきました",
    "post_date": "2024/02/07",
    "url": "https://abap34.com/posts/juliatokyo11.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/poodle-toy/n02113624_1832.jpg",
    "content": "\n\nJuliaTokyo #11 でトークをしてきました\n2/3 に開催された JuliaTokyo #11 で発表をしてきました。\n\n当日は現地50人くらい + オンラインでも30人くらいの方が見ていたらしく、結構盛り上がっていました。\n自分は「Juliaと歩く自動微分の世界」というタイトルで30分トークをさせていただきました。\n資料は　SpeakerDeck ・このサイトにもアップされているのでもしよかったら見てください。\n(この資料自体の内容はともかくとして、最後の一枚はかなり嬉しい人が多いと思います)\n\n<iframe class=\"speakerdeck-iframe\" frameborder=\"0\" src=\"https://speakerdeck.com/player/95948ff2f7a14389992dc1c79d92f5cf\" title=\"Julia Tokyo #11 トーク: 「Juliaで歩く自動微分」\" allowfullscreen=\"true\" style=\"border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;\" data-ratio=\"1.7777777777777777\"></iframe>\n\n自動微分は最近かなり色々勉強しているところですが、Julia周辺で活発に研究されていて面白いです。\n当分の目標は  を理解することですが、どうにも難解すぎて道は遠そうです。\n\nまた、資料は  で書いてるのですが、このくらい長大になってくると単一の markdown ファイルで書くのが辛くなってきます。\nなので、適当に Makefile を組んで分割してビルドできるようにしたのですが、めちゃくちゃ体験が良かったのでおすすめです。\n( \nマクロで低いレイヤに介入しまくって色々できる Juliaはやっぱり楽しいなと感じました。\nこれからも Juliaを使って面白いことができたらなと思います。 運営の皆様、ありがとうございました  🙇‍♂️  \n\n 今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/1RnBDQJyQdI?si=Cm1J6VjCufCCiNrz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n\n",
    "tags": [
      "Julia",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "marp で counter が使えない",
    "post_date": "2024/01/05",
    "url": "https://abap34.com/posts/marp-counter.html",
    "thumbnail_url": "https://abap34.com/posts/marp-counter/img.png",
    "content": "\nmarp で counter が使えない\n普段は marp でスライドを作っています。\n数学チックな長めなスライドを作っていたので定理に番号をつけたくなりテーマに counter を追加しました。\n\n\n↑ こういうの\nでもこれはうまく動きません\n\n調べてみると、 marp は各ページが  で囲まれているので、  を  でリセットしても共有できないようです。\nそんな....\n\n諦めて手で書きましょう.\n\n\n\n",
    "tags": [
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "n 次精度 k 階数値微分の導出",
    "post_date": "2023/11/10",
    "url": "https://abap34.com/posts/n-order-diff.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/cattledog-australian/IMG_2432.jpg",
    "content": "\n\nAbstract\nみなさん微分していますか？私はしています。 数値微分は自動微分のテストに使えるし実装が楽で嬉しいです。 なので精度よくやりたくなってきます。 ところで前進差分の打ち切り誤差が有限の幅  に対して  な一方、 中心差分は  であるというのは割と有名ですが、 各  に対して  で計算する式が常に存在します。(たぶん)\n調べたのですが出てこなかったので導出してみます。\n\n前進差分・中心差分の精度の確認\nまずは前進差分と中心差分の精度を確認してみます。\n\n前進差分は以下のような計算で得られます。\n\n の  における  差分の前進差分による近似  は、\n\n\n\nこれが一次精度、つまり誤差  が  であることを確かめます。\n上の式の右辺をテイラー展開すると、\n\n\n中心差分についても、全く同様に右辺をテイラー展開することで確かめられます。\nPythonでそれぞれ実装してみます。\n\n\n\n\nよく言われる、打ち切り誤差と桁落ちのトレードオフが確認できます\n\n任意の k 階 n 次精度数値微分\n本題を導出しようと思います。 まずは議論のしやすさのために特に  が偶数の場合について考えます。\n\n\n任意の  に対して、 が偶数のとき、 ある  が存在して\n\n として\n\n\nは  を満たす。\n\n\nつまり、 各 ,  に対して中心差分と同様に、微分係数を求めたい点から左右に  ずつ幅をとって点を取り評価した 点に対して、適切な重み付き和が存在して  階導関数の  次精度の数値微分を実現できるということです。\n\n証明してみます。\n\n より、\n\nこれを  について足し合わせて  番目の項以外の係数を  にすればよい。\n\nしたがって、\n\n\nと  を定めたときに  を満たす  が存在すればよい。\nここで、  は ヴァンデルモンド行列 で、  のとき正則。 \nしたがって、  なる  がただ存在して条件を満たす。\n<details> <summary>正則性について</summary> ヴァンデルモンド行列は、\nという各列が等比数列のようになっている行列のことを言います。  (各行の派閥もいるらしいです。)\nヴァンデルモンド行列は、その行列式が\n\nとなることが知られていて、  がすべて異なるときには  でないことがわかります。\nしたがって今回の場合は  であり、  のときはすべて異なるので正則であることがわかります。\n</details>\n\nというわけで確かに存在したうえに一意で、また具体的に計算することができました。\n実際に計算してみようと思います。\n右から  をかけるのはちょうど  列目のベクトルを取り出すことなのでそう実装します。\n\n\n\nと、いい感じに計算できています。\n桁落ちとのトレードオフも確認してみます。\n\n\n打ち切り誤差の変化によって最適な点が変化していることがわかります。\n\n感想線形代数が役に立ってすごい\nまた、上のアルゴリズムは逆行列を求めるところがボトルネックで　時間計算量は 　ですが、 調べたところによるとヴァンデルモンド行列の逆行列は  で求められるようなのでそうすればもう少し早くなりそうです。 (中心差分よりも正確にやろうとする場面すらなかなかみないので実用的ではないですが)\n\n\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/YJRFD1AdaUE?si=as37IuuxoUS9LP5U\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n\n",
    "tags": [
      "数学",
      "Python",
      "微分",
      "日記"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "自明ギャグの定義とその発展",
    "post_date": "2023/10/13",
    "url": "https://abap34.com/posts/jimei.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/clumber/n02101556_3878.jpg",
    "content": "\n 　Abstract自明ギャグとは、一見正しそうな定義を自明に満たすものの、 経験的には非自明である物質を面白がるギャグである。\n本記事は、この自明ギャグの定義や基本的構造、面白さの分析、 発展について述べ、乱立している自明ギャグについての整理を行うことを試みた。\n\n自明ギャグの定義自明丼\n具体例から始める。\n自明ギャグの原点は、\n\n「自明丼」  である。 \n\n\n「丼」を以下のように定義しよう。\n\n\n丼は、米の上に、以下の条件を満たす集合  が乗っているものである。\n\nさて、この場合具体的にどのようなものが丼になるかを考えると、次のようなことがわかる。\n\n\n米の上に空集合が乗っているものは丼である。\nこれは丼の定義から自明であるし、　\nやや不思議な言い方だが、「最も自明である」丼であろう。\nなので、この丼のことを 自明丼 と呼ぶことにする。\n\n\n\nこのように、\n\n自然そうな定義の条件に対して、ある物体が定義を数学的には自明に満たすが、日常的な感覚からすると極めて非自明であることのギャップを利用したギャグを自明ギャグと呼ぶ。\n\n\n(ここでの「自明に満たす」という意味合いはかなり厳しくとることが共通見解である。どこまでが、何が「自明」の根拠として採用できるのかは、この後の「自明ギャグのように見えるが、自明ギャグではないもの」のセクションなどを参照してほしい。)\n\n自然そうな定義の条件に対して、ある物体が定義を数学的には自明に満たすが、日常的な感覚からすると極めて非自明であることのギャップを利用したギャグを自明ギャグと呼ぶ。\n以下は、自明丼と極めて構造が似通っている自明ギャグの例である。\n\nハンバーガをバンズの間に具の集合が挟まっているものと定義したとき、 バンズだけのハンバーガは自明ハンバーガである。\n小銭入れを財布の中に通貨の集合が入っているものと定義したとき、 中身が空の小銭入れは自明小銭入れである。\n\nこれらは\n定義が単一の集合に対して与えられているその集合が空集合ならば自明に条件を満たす\nというタイプの自明ギャグである。\nこのようなタイプの自明ギャグは、「自明丼型の自明ギャグ」と呼ばれる。\n\n\n自明ギャグのように見えるが、自明ギャグではないもの\nさて、ここまでで登場した自明ギャグの例をもとに自明ギャグを考える場合、典型的に陥る 誤謬をいくつか紹介しておく。\n\nまずは「寿司型の自明ギャグ」である。\n以下のようなギャグは、自明丼型の自明ギャグのように見えるが、自明ギャグではないものである。\n\n寿司を米の上にネタが乗っているものと定義したとき、 シャリだけの寿司は自明寿司である。\nこれは一見自明ギャグのように見えるが、自明ギャグにおいて最も重要である「自明にするために変化する部分」がなんであるかが不明瞭である。\n正確に書き直すと以下のようになるであろう。\n\n寿司を米の上にネタ集合の元が乗っているものと定義したとき、 シャリだけの寿司は自明寿司である。\nすると、この場合自明寿司のシャリの上に乗っているのは  ではなくいわば「空オブジェクト」で、そもそもこれはネタの集合の元ではない。\nしたがって、このギャグは自明ギャグとして成立していない。\n自明丼は最も典型的なタイプの自明ギャグだが、変化する部分が集合となっているかどうかに注意が必要である。\n\n次が、「非自明自明ギャグ」である。\n以下のようなギャグについて考えよう。\n\n丼を米の上に具の集合が乗っているものと定義したとき、 エビの天ぷらが  個乗っている丼は自明丼である。\nこれは、自明ギャグのように見えるが、非自明自明ギャグと言われるタイプのギャグで、自明ギャグではないと基本的には考えられている。\n\nというのも、これが丼であるかどうかを判定するには、エビの天ぷらが具であるかどうかという議論が必要であり、 空集合の場合の「自明度」と比較すれば自明であると言えばないと考えられているからである。\n\nつまり、自明ギャグは、\n公理(vacuous truthのような) 完全に認められていて、広く知られている事実から直ちに従う\nレベルの「自明度」が求められており、特に現在は自明丼に代表されるように空集合などを利用したもののみが認められる風潮が強い。\nとはいえこれでは極めて自明ギャグの幅が狭くなってしまうため、自明ギャグの「自明度」を保っての拡張が考えられている。\n\n自明ギャグの発展自明丼からの一般化\nさて、ここまでは空集合を利用した極めて限定的なギャグのみが認められていたが、現在はこれらの拡張が盛んに研究されている。\n代表例は、空列への応用である。\n再び具体例から始める。\n\nコーデを、何も服を着ていない状態から、服を着る動作の列を適用して得られる状態と定義したとき、 何も服を着ていない状態は自明コーデである。\nこれは、空集合を空列に変えたのみであり、自明ギャグの一種であると広く認められていて、\n「コーデ型の自明ギャグ」と呼ばれている。\n\nコーデ型の自明ギャグは、動作を繰り返す日常の行為をよく表現できるため、非常に活発に開拓されているタイプの自明ギャグである。\n対比型の自明ギャグ、最上川型の自明ギャグ\nさらに、発展系として極めて自由なタイプのギャグである対比型の自明ギャグと最上川型の自明ギャグがある。\n注意点として、\n\n対比型の自明ギャグ、最上川型の自明ギャグは、自明ギャグではない。\nことに注意が必要である。\n\n\nまず、対比型の自明ギャグは、条件を満たすものが二つしか存在しない場合にそれぞれを自明/非自明に分類することでユーモアを生み出すギャグである。\n例えば、\n普通の傘を自明傘と呼び、折りたたみ傘を非自明傘と呼ぶ結婚式の挨拶で実の父親を自明親と呼び、義理の父親を非自明親と呼ぶ\nというようなものが対比型の自明ギャグと呼ばれる。\nこれは、もはや自明ギャグの定義からは外れているが、自明というワードが中核概念であるため、このような非自明な命名がなされている。\n次に、最上川型の自明ギャグは\n非自明最上川非自明大谷翔平\nのような固有名詞に「非自明」とつけることで理解不能な状況を作り出すギャグである。\nこれも、もはや自明ギャグの定義からは外れているが、同様に自明というワードが中核概念であるため、このような命名がなされている。\n\nConclusion\n自明ギャグは、自明丼を起源として、現在では様々なタイプの自明ギャグが存在する。\nさらに、構造や面白さの理論的分析も進んでおり今後の発展が期待される分野である。\n一方で課題としては、このギャグが通じる相手があまりにも限定的であることが知られているため、 自明に良いタイミングでの使用が求められている。 \n\n\n脚注\n 丼に定義を入れて、また空集合を認めるというユーモアは  がおそらく発祥と思われる。\n 理系単科大学での使用など。 \n\n\n\n\n",
    "tags": [
      "自明ギャグ"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "DrRacketがかなりおもしろIDEだった",
    "post_date": "2023/10/02",
    "url": "https://abap34.com/posts/racket.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/setter-english/n02100735_8071.jpg",
    "content": "\n\n\nDrRacket 衝撃の機能今日で夏休みが終わって後期の授業が始まりました！早起きが辛い！！！\n講義は、「関数型プログラミング基礎」というのが始まりました。\nSchemeを使うと言われていたので、 、 RacketというSchemeの方言を使うらしく、DrRacketというIDEを使えと言われました。\n初回は「慣れるためにとりあえず使ってみて」というなんとも投げやりな感じだったのですが、指定されたサンプルコードを見ていると、\n\n！？ なんかソースコードに急にロケットの画像が入っています。えぇ...\nつまり、\n\n\n(全然関係ないですが大谷選手ホームラン王おめでとうございます！！！！)\n\n一応ソースコードの中身を見てみる流石に衝撃的すぎます。一応  の中身を見てみます。\n\nファイルの先頭を見ると、\n\nみたいなことが書いてあり、そもそも素(?)のracketのソースコードではなく、DrRacket前提のソースコードになっているみたいです。\n\n続いて、\n\nみたいなのがあり画像のバイナリがそのまま入っていました。パワーを感じる。\n今日のラーメン後期になって学食がオープンしたので行ってきました。\n机が広くて友達と喋りやすくて良さげです。\nあとごま団子が謎に入荷していて良かったです。\n \n\n\n\n\n\n",
    "tags": [
      "日記",
      "Racket",
      "Lisp",
      "Scheme"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "2023年度前期振り返り",
    "post_date": "2023/10/01",
    "url": "https://abap34.com/posts/hurikaeri_2023_0.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/kuvasz/n02104029_951.jpg",
    "content": "\n\n一番嫌いな...冬に...突入！！\n2023年度前期の振り返り\n大体時系列順です。\n(Q_Q) ?\n「いかしかめか」と読みます。部内ハッカソンで作りました。部内SNSでの質問と回答を収集して自動で収集しページを構築、類似質問と回答をサジェストします。諸々とサジェスト周りの実装を担当しましたが、計算資源がきつい中でサジェストしなきゃで、面白かったです。bot と検索エンジンの実装と発表を担当しました発表スライド : \n\n\nWuff\nコメントをするとリアルタイムにニコニコみたいな感じで画面に流れるやつです。LINEみたいな感じでみんなでチャットできます。WebSocket でみんなのコメントを同期しています。Google Cloud Run で動かしていますが Dockerfile 書いてぽちぽちするだけで動かせて感動しました配信する自分は適当に収集して表示するスクリプトを書いて OBSに合成したり、対面で発表するときは GeekTool で透過ウィンドウに表示したりして使っていました。\n\n\nDacQ\n部内 mini Kaggleです。昨年度にも先輩の間で開発の構想があったみたいなのですが頓挫してしまっていて、えいやと作りました。部内 PaaS の Neoshowcase を使うとめちゃくちゃ簡単に traP部員だけが使えるように認証できて、感動しました\n\n\n機械学習の入門資料\n400ページ近くの機械学習の入門資料を作りました。 めちゃくちゃ大変だったけど割と楽しかったです。内容をきちんとめに直してどこかに出したいですね　(色々と微妙なところがある上に書き込み前提の資料なので)\n\n機械学習講習会\nここまで 3つの内容は全部これです新入部員向けの教育でやりました。全7回、合計10時間講義 + 演習やりました。内容は traP のブログにまとまっているので読んでみてください。 個人的には結構頑張りました。サークルを卒業した先輩とか弊学の先生とかに結構褒められていて嬉しかったです。ブログ: \n\nJITrench.jl の計算グラフの最適化機能\nJITrench.jl で、静的な計算グラフの構築とかそれのLayerFusionとか定数ノードの伝播とかができるようになりました。好きに開発するだけで100点がもらえる謎の講義の発表に間に合わせるべくかなりバグを仕込んで完成させてしまったので直すのがかなり面倒でなかなかリリースされません。どうして...色々論文読んだり実装するのがちょっとは上手くなってきたかなという気がします。Readableは神です。\n\n\nJuliaで並列AlphaBeta法\n大学の人工知能の講義でなんかレポートを書けと言われたので書いて授業で発表しました。pdfを貼っているだけですが記事にしているので読んでみてください。 記事: 並列化もしんどかったけどビットボードで脳が破壊されました\n\n\nALMO\nレポジトリ: このページを作っているMarkdownパーサです。WebAssemblyで実行可能なコードブロックとかプロットとかジャッジが作れます。かなりかなりブラッシュアップされて v1.0 リリース間近です。ドキュメントを書くのが面倒でなかなかリリースされない\n\n\n部内コンペ (sponsored by ピクシブ社) の運営\n去年から運営しているコンペをやりました。今年はスポンサーがついたので、それも含めて色々やることが多くて大変でしたがめちゃくちゃ楽しかったです。開催記録が例によって traP のブログにまとまっているので読んでみてください。ブログ: \n\nその他プロ野球贔屓球団が10/1の最終戦を終えた時点で最下位です。今年の中日より弱いのはやばいドイツ語朝起きれなさすぎて単位を落としました\n後期の目標とにかく頑張ります。\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/A2k6ZO6B0A8?si=llQhLWX-WATgUhGN\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n",
    "tags": [
      "日記",
      "振り返り",
      "ネタ"
    ],
    "featured": "true",
    "external": false
  },
  {
    "title": "gRPCを使ったプロセス間通信でGoからいい感じに学習済みモデルを呼び出して推論",
    "post_date": "2023/09/30",
    "url": "https://abap34.com/posts/grpc_ml.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/finnish-lapphund/mochilamvan.jpg",
    "content": "\n 　推論を goでやりたい人がいる\n世の中ではGoを使っている人が割と多く、 機械学習の人が一緒に何かやろうと思うとGoを使う必要が割とあります。\n\n\nとなるとPython製のライブラリで作った学習済みモデルをGoからいい感じに呼んで推論する必要があります。\n\nところが結構な場合、Goでのいい感じの推論は公式にサポートされていません。\n前処理系は  でそれなりにいけそうというのがわかったのですが、 学習済みモデルを動かす部分は非公式でも全然ちゃんとサポートされているものが出てこなくて厳しい気持ちになります。 (しんどいというよりは、もはやちょっと無理そうという感じ)\n\nなので、gRPCを使って別個建てたPythonのプロセスに対してGoからお願いして推論してもらうことにします。\n\n\n実装 をとても参考にさせていただきました。ありがとうございます。\nこういうファイル構造にします。\n\nで、はこんな感じです。\n\nえ、これだけで諸々作ってくれるらしいです。天才？\nセットアップして、\n\nGo用のコードを生成します。\n\nPython用のコードを生成します。\n\n\nこんな感じになります。\n\nあとはサーバ側をPython, クライアント側をGoで書きます。\nサーバ側\n\nクライアント側\n\nこれで  を実行させて、 csvファイルを投げ込むと.....\n\n推論結果が返ってきました。笑顔に。\n\nまとめgRPCでいい感じにPythonで作ったモデルをGoから呼び出せそう機械学習の人は機械学習のことを考えてWebの人はWebできて嬉しそう個人的にはどれくらい速度が出るのか気になります！(テストデータがクソデカなときとか)ので暇になったら調べてみます。\n今日の一曲\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DeGkiItB9d8?si=GFL6bnQBYiDs7uLG\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n\n\n",
    "tags": [
      "日記",
      "go",
      "web",
      "機械学習",
      "python"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "頻度分析してシーザー暗号を複合するやつは実測してみると意外とうまく行く話",
    "post_date": "2023/09/29",
    "url": "https://abap34.com/posts/caesar.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/hound-blood/n02088466_9046.jpg",
    "content": "\n\nシーザー暗号と頻度分析シーザー暗号は最も有名な暗号ですよね。\n仕組みは単純で、適当に定めた  個分、アルファベットをずらすだけです。\n例えば  のとき、  は  になります。\n\nそして当然ですが、暗号化された分は、逆の方向に  個分ずらすことで復号できます。\n\nしたがって、シーザ暗号によって暗号化された文章に対してうまくずらした文字数を推定できれば暗号を突破できます。\n\nその一番有名な方法が頻度分析です。 これは、英語の文章では特定の(Characterの意味で)文字が出現する頻度が高いことを利用します。 例えば、英語の文章では  が一番出現頻度が高いです。　したがって、暗号化された文で最も出現頻度が高い文字が  から変換されたものであると考えてずらした幅を推定できます。\n\nというかなり簡素な仕組みの解読法ですが、これがどれくらいうまく行くのか気になるところです。\n\nチャチャっと調べてみます。\n を適当に持ってきて、 10000分くらいを抽出して暗号化　→ 解読というのをやってみます。\n横軸にそれぞれの分の単語数、解読の成功率を書いてみます。\n\nという結果が得られました。\nこんな感じで、60語くらいの文であればなんと70%くらいはうまく行くようです。\n他にも、特定の部分文字列が出現しやすかったり、二番目、三番目に出現しやすい文字を使うことでもっと正確に推定することができるでしょうから、 意外とうまく行くもんだなぁという感想です。\n\nというレポートを1年生の時に書いたのでブログネタとして消費しました。 去年の自分、ありがとうございました。\n\n\n\n",
    "tags": [
      "ネタ"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "オセロ探索の並列化の戦略",
    "post_date": "2023/09/25",
    "url": "https://abap34.com/posts/parallel_othello.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/malinois/n02105162_2896.jpg",
    "content": "\n？\nちょっと前に人工知能の講義で発表したスライドです。\nレポートを書いて優秀だったら発表できて加点されるみたいな講義で、 発表した + 最優秀だったらしいです。すごい。\nTwitterに上げたら実装で参考にした です。\n\n最初の方に並列化についてやや微妙な説明が続きますが、 発表時間との兼ね合いとか、大学の同級生がターゲットのため、 あんまり詳しく説明しても空気がやばくなりそうで、 心の目で読んでもらえればと思います。\n\n<iframe src=\"https://drive.google.com/viewerng/viewer?embedded=true&url=https://raw.githubusercontent.com/abap34/ParallelOthello.jl/main/slide.pdf\" width=\"100%\" height=\"500px\"></iframe>\n\n\n\n",
    "tags": [
      "機械学習",
      "ゲームAI",
      "Julia"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Juliaで実行時間を制限する用のタイマー",
    "post_date": "2023/09/24",
    "url": "https://abap34.com/posts/julia_timer.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/spaniel-sussex/n02102480_4923.jpg",
    "content": "\nJuliaで実行時間を制限する用のタイマー\n\nヒューリスティックな手法などで、 適当に定めた時間だけ探索して打ち切りたいという場合があります。\n競プロなどでも使える簡単めでシンプルめなJuliaでの実装を書きました。\n\n\n\n使い方は、\n\n\nという感じです。\n で計測のリセット、  で経過時間の割合を取得できます。 (焼きなまし法などで使う用です。)\n\n\n\n\n\n",
    "tags": [
      "Julia",
      "競技プログラミング",
      "日記"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "Scheme入門した m1macでのScheme環境構築",
    "post_date": "2023/09/24",
    "url": "https://abap34.com/posts/hello_scheme.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/redbone/n02090379_5393.jpg",
    "content": "\n\n\nMosh\n後期から関数型プログラミングの授業でSchemeを使うらしいので少し触っていた。\nm1macで環境構築しようと思ったけど、直接動かすのがめんどそうで、(Rosettaなり使えばいいんだけど) どうしようかと思っていたら  を見かけたのでこれを入れてみた、　\n\n\n\nTwitterでも有名な人が作ったSchemeの処理系で、サクッと入れられてちゃんと動いた。\n\nとりあえず  の基礎知識のパートを一通り読んで動かした。\n\n(それはそれとして、このサイトの解説の充実具合がすごすぎる...)\n\n\n\n\n",
    "tags": [
      "日記",
      "関数型プログラミング",
      "Scheme"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "ブログを自作Markdownパーサで作り直しました",
    "post_date": "2023/08/29",
    "url": "https://abap34.com/posts/rebuild_abap34_com.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/clumber/n02101556_5007.jpg",
    "content": "\n\nうおータイトルの通り、ブログを自作Markdownパーサで作り直しました。\n中身は \n<a href=\"https://github.com/abap34/ALMO\"><img src=\"https://github-link-card.s3.ap-northeast-1.amazonaws.com/abap34/ALMO.png\" width=\"460px\"></a>\nです。\nZennにもを書いたんですが、  PyOdideを使って実行環境・ジャッジ同梱のHTMLが吐けるというパーサです。\nこれをGitHub Actionsで動かしてこのページを作っています。\nもちろん普通のMarkdownも書けるので、基本的にはそういう運用になっていくと思いますが、 せっかく作ったので今後はブログにもうちょっと記事を書いていこうと思います。\nここ一週間くらいの近況報告\nサークル\n部内のデータ分析コンペを今年も開催しました。\n今年は、ピクシブ株式会社様にスポンサーしていただいて、 題材も含めいろいろ面白いことができたと思ってます。\n最終的に38チーム + 800近いサブミッションと、学生サークル内のコンペとしては なかなかの盛り上がりだったんじゃないかと思います。\n開催記をまさに今書いてる途中です(飽きてこのブログのリニューアル作業をしていました)\nそのうちtraPのブログにアップロードします。\nおべんきょう\n測度論の勉強をひそかにやっています。\n\n情報工学系(僕の所属している学科)は、確率統計の授業はあるんですが、 測度論含め「確率論」の基礎のきちんとした(?)授業はなく、数理計算科学系という同じ学院のもう一つの系でその辺りをかなりきちんとやる授業が開講されています。\n\nが、こちらの授業が情報工学系の授業とかなりコンフリクトしており、 履修するのが難しいということが判明したので、 とりあえず自分でやってみることにしました。\n\n今は、 を進めています。\n中日ドラゴンズ\n12球団の中で一番面白い。\n東京ヤクルトスワローズ\n弱い。\n\n\n\n\n",
    "tags": [
      "Web",
      "Markdown",
      "WebAssembly"
    ],
    "featured": false,
    "external": false
  },
  {
    "title": "GitHub Actionsで過去コミットとかを参照したいときはfetch-depthを指定しないとダメだった",
    "post_date": "2023/08/29",
    "url": "https://abap34.com/posts/githubactions_trap.html",
    "thumbnail_url": "https://images.dog.ceo/breeds/clumber/n02101556_5007.jpg",
    "content": "\n が通らないでは、 マークダウンファイルで差分があったときだけビルドするために\n\n\nみたいなことをしていますが、これを普通に書くだけでは となります。\n\n\n全然原因がわからず、 を見にいくと、\n\n\nすいません。 READMEの一番上に書いてありました。\n対応策\n\nとして全てのコミットを参照できるようにすると が動いて差分だけビルドできるようになりました。\n\n\n\n\n",
    "tags": [
      "GitHub Actions",
      "GitHub",
      "git"
    ],
    "featured": false,
    "external": false
  }
]